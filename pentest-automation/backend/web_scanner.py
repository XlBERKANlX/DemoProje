"""
Web Scanner Orchestrator
Manages Gobuster and Nikto scans concurrently
"""

import uuid
import threading
import time
from typing import Dict, List, Optional
from gobuster_scanner import GobusterScanner
from nikto_scanner import NiktoScanner

class WebScanner:
    def __init__(self):
        self.active_scans = {}  # scan_id -> scan_state
        self.lock = threading.Lock()
        
    def create_scan(self, params: Dict) -> str:
        """
        Create a new web scan
        
        Args:
            params: {
                'target_url': 'https://example.com',
                'gobuster': {'enabled': True, 'threads': '10', 'delay': '0'},
                'nikto': {'enabled': True, 'scan_type': '2', 'delay': '0'},
                'ssl_enforce': True,
                'wordlist': '/admin\n/login'
            }
        
        Returns:
            scan_id
        """
        scan_id = str(uuid.uuid4())
        
        scan_state = {
            'scan_id': scan_id,
            'status': 'initializing',
            'target_url': params.get('target_url'),
            'gobuster': {
                'enabled': params.get('gobuster', {}).get('enabled', False),
                'status': 'pending',
                'results': [],
                'error': None
            },
            'nikto': {
                'enabled': params.get('nikto', {}).get('enabled', False),
                'status': 'pending',
                'output': [],
                'error': None
            },
            'created_at': time.time(),
            'completed_at': None
        }
        
        with self.lock:
            self.active_scans[scan_id] = scan_state
        
        # Start scan in background thread
        scan_thread = threading.Thread(
            target=self._execute_scan,
            args=(scan_id, params),
            daemon=True
        )
        scan_thread.start()
        
        return scan_id
    
    def _execute_scan(self, scan_id: str, params: Dict):
        """
        Execute scan in background thread
        """
        try:
            with self.lock:
                self.active_scans[scan_id]['status'] = 'running'
            
            gobuster_enabled = params.get('gobuster', {}).get('enabled', False)
            nikto_enabled = params.get('nikto', {}).get('enabled', False)
            
            # Prepare threads for concurrent execution
            threads = []
            
            # Gobuster thread
            if gobuster_enabled:
                gobuster_thread = threading.Thread(
                    target=self._run_gobuster,
                    args=(scan_id, params),
                    daemon=True
                )
                threads.append(gobuster_thread)
                gobuster_thread.start()
            
            # Nikto thread
            if nikto_enabled:
                nikto_thread = threading.Thread(
                    target=self._run_nikto,
                    args=(scan_id, params),
                    daemon=True
                )
                threads.append(nikto_thread)
                nikto_thread.start()
            
            # Wait for all threads to complete
            for thread in threads:
                thread.join()
            
            # Mark scan as completed
            with self.lock:
                scan_state = self.active_scans.get(scan_id)
                if scan_state and scan_state['status'] != 'cancelled':
                    scan_state['status'] = 'completed'
                    scan_state['completed_at'] = time.time()
            
            print(f"[INFO] Web scan {scan_id} completed")
            
        except Exception as e:
            print(f"[ERROR] Web scan {scan_id} failed: {e}")
            with self.lock:
                if scan_id in self.active_scans:
                    self.active_scans[scan_id]['status'] = 'error'
                    self.active_scans[scan_id]['error'] = str(e)
    
    def _run_gobuster(self, scan_id: str, params: Dict):
        """Run Gobuster scan"""
        try:
            with self.lock:
                self.active_scans[scan_id]['gobuster']['status'] = 'running'
            
            scanner = GobusterScanner()
            
            # Create temporary wordlist file
            wordlist_content = params.get('wordlist', '')
            if not wordlist_content:
                raise ValueError("Wordlist is required for Gobuster")
            
            wordlist_path = scanner.create_wordlist_file(wordlist_content)
            
            try:
                # Prepare Gobuster parameters
                gobuster_params = {
                    'target_url': params.get('target_url'),
                    'wordlist_path': wordlist_path,
                    'threads': params.get('gobuster', {}).get('threads', '10'),
                    'delay': params.get('gobuster', {}).get('delay', '0'),
                    'ssl_enforce': params.get('ssl_enforce', False)
                }
                
                # Callback for real-time updates
                def on_result(result):
                    with self.lock:
                        if scan_id in self.active_scans:
                            self.active_scans[scan_id]['gobuster']['results'].append(result)
                
                # Run scan
                results = scanner.scan(gobuster_params, callback=on_result)
                
                with self.lock:
                    if scan_id in self.active_scans:
                        self.active_scans[scan_id]['gobuster']['status'] = 'completed'
                        self.active_scans[scan_id]['gobuster']['results'] = results
                
            finally:
                # Clean up temporary wordlist
                import os
                if os.path.exists(wordlist_path):
                    os.remove(wordlist_path)
                    
        except Exception as e:
            print(f"[ERROR] Gobuster scan failed: {e}")
            with self.lock:
                if scan_id in self.active_scans:
                    self.active_scans[scan_id]['gobuster']['status'] = 'error'
                    self.active_scans[scan_id]['gobuster']['error'] = str(e)
    
    def _run_nikto(self, scan_id: str, params: Dict):
        """Run Nikto scan"""
        try:
            with self.lock:
                self.active_scans[scan_id]['nikto']['status'] = 'running'
            
            scanner = NiktoScanner()
            
            # Prepare Nikto parameters
            nikto_params = {
                'target_url': params.get('target_url'),
                'scan_type': params.get('nikto', {}).get('scan_type', ''),
                'delay': params.get('nikto', {}).get('delay', '0'),
                'ssl_enforce': params.get('ssl_enforce', False)
            }
            
            # Callback for real-time updates
            def on_output(output_line):
                with self.lock:
                    if scan_id in self.active_scans:
                        self.active_scans[scan_id]['nikto']['output'].append(output_line)
            
            # Run scan
            output = scanner.scan(nikto_params, callback=on_output)
            
            with self.lock:
                if scan_id in self.active_scans:
                    self.active_scans[scan_id]['nikto']['status'] = 'completed'
                    self.active_scans[scan_id]['nikto']['output'] = output
                    
        except Exception as e:
            print(f"[ERROR] Nikto scan failed: {e}")
            with self.lock:
                if scan_id in self.active_scans:
                    self.active_scans[scan_id]['nikto']['status'] = 'error'
                    self.active_scans[scan_id]['nikto']['error'] = str(e)
    
    def get_scan_status(self, scan_id: str) -> Optional[Dict]:
        """Get current status of a scan"""
        with self.lock:
            return self.active_scans.get(scan_id)
    
    def cancel_scan(self, scan_id: str) -> bool:
        """Cancel a running scan"""
        with self.lock:
            scan_state = self.active_scans.get(scan_id)
            if not scan_state:
                return False
            
            if scan_state['status'] in ['completed', 'cancelled', 'error']:
                return False
            
            scan_state['status'] = 'cancelled'
            # Note: Individual scanner cancellation would need to be implemented
            # For now, we just mark it as cancelled
            return True
    
    def cleanup_old_scans(self, max_age_seconds: int = 3600):
        """Remove scans older than max_age_seconds"""
        current_time = time.time()
        with self.lock:
            scan_ids_to_remove = []
            for scan_id, scan_state in self.active_scans.items():
                age = current_time - scan_state['created_at']
                if age > max_age_seconds:
                    scan_ids_to_remove.append(scan_id)
            
            for scan_id in scan_ids_to_remove:
                del self.active_scans[scan_id]
            
            if scan_ids_to_remove:
                print(f"[INFO] Cleaned up {len(scan_ids_to_remove)} old scans")
