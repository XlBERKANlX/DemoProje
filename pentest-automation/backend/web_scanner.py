"""
Web Scanner Orchestrator
Manages Gobuster and Nikto scans with smart filtering and sequential execution
"""

import uuid
import threading
import time
from typing import Dict, List, Optional
from gobuster_scanner import GobusterScanner
from nikto_scanner import NiktoScanner

class WebScanner:
    def __init__(self):
        self.active_scans = {}  # scan_id -> scan_state
        self.lock = threading.Lock()
        
    def create_scan(self, params: Dict) -> str:
        """
        Create a new web scan
        
        Args:
            params: {
                'target_url': 'https://example.com',
                'gobuster': {'enabled': True, 'threads': '10', 'delay': '0'},
                'nikto': {'enabled': True, 'scan_type': '2', 'delay': '0'},
                'ssl_enforce': True,
                'recursive': True,
                'recursive_mode': 'targeted',  # 'base' or 'targeted'
                'wordlist': '/admin\\n/login'
            }
        
        Returns:
            scan_id
        """
        scan_id = str(uuid.uuid4())
        
        scan_state = {
            'scan_id': scan_id,
            'status': 'initializing',
            'target_url': params.get('target_url'),
            'gobuster': {
                'enabled': params.get('gobuster', {}).get('enabled', False),
                'status': 'pending',
                'results': [],
                'error': None
            },
            'nikto': {
                'enabled': params.get('nikto', {}).get('enabled', False),
                'status': 'pending',
                'output': [],
                'error': None
            },
            'created_at': time.time(),
            'completed_at': None
        }
        
        with self.lock:
            self.active_scans[scan_id] = scan_state
        
        # Start scan in background thread
        scan_thread = threading.Thread(
            target=self._execute_scan,
            args=(scan_id, params),
            daemon=True
        )
        scan_thread.start()
        
        return scan_id
    
    def _execute_scan(self, scan_id: str, params: Dict):
        """
        Execute scan with smart filtering and sequential workflow
        """
        try:
            with self.lock:
                self.active_scans[scan_id]['status'] = 'running'
            
            gobuster_enabled = params.get('gobuster', {}).get('enabled', False)
            nikto_enabled = params.get('nikto', {}).get('enabled', False)
            recursive = params.get('recursive', False)
            recursive_mode = params.get('recursive_mode', 'base')
            
            # Debug: Show workflow decision
            print(f"[DEBUG] Workflow Decision:")
            print(f"  - Gobuster: {gobuster_enabled}")
            print(f"  - Nikto: {nikto_enabled}")
            print(f"  - Recursive: {recursive}")
            print(f"  - Recursive Mode: {recursive_mode}")
            
            # Sequential mode: Gobuster â†’ Smart Filter â†’ Nikto on targets
            if gobuster_enabled and nikto_enabled and recursive and recursive_mode == 'targeted':
                print(f"[INFO] âœ… SEQUENTIAL MODE: Gobuster â†’ Nikto (Targeted)")
                
                # 1. Run Gobuster first
                self._run_gobuster(scan_id, params)
                
                # 2. Smart filtering: Get critical directories
                critical_paths = self._smart_filter_paths(scan_id)
                print(f"[INFO] Smart filter found {len(critical_paths)} critical paths")
                
                # 3. Run Nikto on base URL + critical paths
                self._run_nikto_on_targets(scan_id, params, critical_paths)
            
            # Recursive base mode: Nikto with -root on base URL only
            elif nikto_enabled and recursive and recursive_mode == 'base':
                print(f"[INFO] âš¡ RECURSIVE BASE MODE: Nikto (Base Only)")
                
                # Run Gobuster if enabled (concurrent)
                if gobuster_enabled:
                    gobuster_thread = threading.Thread(
                        target=self._run_gobuster,
                        args=(scan_id, params),
                        daemon=True
                    )
                    gobuster_thread.start()
                
                # Run Nikto with recursive on base URL
                params['nikto']['recursive'] = True
                self._run_nikto(scan_id, params)
                
                if gobuster_enabled:
                    gobuster_thread.join()
            
            # Concurrent mode: Run both simultaneously (no recursive)
            else:
                print(f"[INFO] ðŸ”„ CONCURRENT MODE: Gobuster + Nikto (No Recursive)")
                threads = []
                
                if gobuster_enabled:
                    gobuster_thread = threading.Thread(
                        target=self._run_gobuster,
                        args=(scan_id, params),
                        daemon=True
                    )
                    threads.append(gobuster_thread)
                    gobuster_thread.start()
                
                if nikto_enabled:
                    nikto_thread = threading.Thread(
                        target=self._run_nikto,
                        args=(scan_id, params),
                        daemon=True
                    )
                    threads.append(nikto_thread)
                    nikto_thread.start()
                
                for thread in threads:
                    thread.join()
            
            # --- AI ANALYSIS INTEGRATION ---
            print("[INFO] Starting AI Analysis of Web Scan Results...")
            
            try:
                # 1. Collect Outputs
                nikto_output = "\n".join(self.active_scans[scan_id]['nikto'].get('output', []))
                # Gobuster results are list of dicts. We pass the list directly.
                gobuster_output = self.active_scans[scan_id]['gobuster'].get('results', [])
                
                # 2. Parse Results
                # Import locally to avoid circular imports if any
                from ai_analyzer import AIAnalyzer
                analyzer = AIAnalyzer()
                
                parsed_data = analyzer.parse_web_scan_results(nikto_output, gobuster_output)
                
                # 3. Trigger AI Analysis
                ai_results = analyzer.analyze_web_scan(parsed_data)
                
                # 4. Save to Scan State
                with self.lock:
                    self.active_scans[scan_id]['ai_analysis'] = ai_results
                    print("[INFO] AI Analysis saved to scan state.")
                    
            except Exception as e:
                print(f"[ERROR] AI Integration failed: {e}")
                with self.lock:
                    self.active_scans[scan_id]['ai_analysis_error'] = str(e)

            # Mark scan as completed
            with self.lock:
                scan_state = self.active_scans.get(scan_id)
                if scan_state and scan_state['status'] != 'cancelled':
                    scan_state['status'] = 'completed'
                    scan_state['completed_at'] = time.time()
            
            print(f"[INFO] Web scan {scan_id} completed")
            
        except Exception as e:
            print(f"[ERROR] Web scan {scan_id} failed: {e}")
            with self.lock:
                if scan_id in self.active_scans:
                    self.active_scans[scan_id]['status'] = 'error'
                    self.active_scans[scan_id]['error'] = str(e)
    
    def _smart_filter_paths(self, scan_id: str) -> List[str]:
        """
        Smart filtering: Extract critical paths from Gobuster results
        
        Criteria:
        - Status Code: 200 or 301
        - Type: Directory
        - Priority keywords: admin, config, phpinfo, backup, etc.
        - Limit: Top 3-5 paths
        """
        with self.lock:
            gobuster_results = self.active_scans[scan_id]['gobuster']['results']
        
        print(f"[DEBUG] Smart Filter Input: {len(gobuster_results)} total paths from Gobuster")
        
        # Filter by status code only (200 or 301)
        # Don't filter by type - include both files and directories
        filtered = [
            r for r in gobuster_results
            if r.get('status') in [200, 301]
        ]
        
        print(f"[DEBUG] After status filter: {len(filtered)} paths (200/301)")
        print(f"[DEBUG] Sample paths: {[r.get('path') for r in filtered[:3]]}")
        
        # Priority keywords (higher priority = more critical)
        priority_keywords = {
            'admin': 10,
            'phpinfo': 9,
            'config': 8,
            'backup': 7,
            'database': 7,
            'db': 7,
            'api': 6,
            'upload': 6,
            'login': 5,
            'user': 4,
            'test': 3,
        }
        
        # Score each path
        scored_paths = []
        for result in filtered:
            path = result.get('path', '').lower()
            score = 0
            
            # Check for priority keywords
            for keyword, priority in priority_keywords.items():
                if keyword in path:
                    score += priority
            
            scored_paths.append((score, result['path']))
        
        # Sort by score (descending) and take top 5
        scored_paths.sort(reverse=True, key=lambda x: x[0])
        critical_paths = [path for score, path in scored_paths[:5]]
        
        print(f"[DEBUG] Top 5 critical paths (scored):")
        for score, path in scored_paths[:5]:
            print(f"  - {path} (score: {score})")
        
        return critical_paths
    
    def _run_gobuster(self, scan_id: str, params: Dict):
        """Run Gobuster scan"""
        try:
            with self.lock:
                self.active_scans[scan_id]['gobuster']['status'] = 'running'
            
            scanner = GobusterScanner()
            
            # Create temporary wordlist file
            wordlist_content = params.get('wordlist', '')
            if not wordlist_content:
                raise ValueError("Wordlist is required for Gobuster")
            
            wordlist_path = scanner.create_wordlist_file(wordlist_content)
            
            try:
                # Prepare Gobuster parameters
                gobuster_params = {
                    'target_url': params.get('target_url'),
                    'wordlist_path': wordlist_path,
                    'threads': params.get('gobuster', {}).get('threads', '10'),
                    'delay': params.get('gobuster', {}).get('delay', '0'),
                    'ssl_enforce': params.get('ssl_enforce', False)
                }
                
                # Callback for real-time updates
                def on_result(result):
                    with self.lock:
                        if scan_id in self.active_scans:
                            self.active_scans[scan_id]['gobuster']['results'].append(result)
                
                # Run scan
                results = scanner.scan(gobuster_params, callback=on_result)
                
                with self.lock:
                    if scan_id in self.active_scans:
                        self.active_scans[scan_id]['gobuster']['status'] = 'completed'
                        self.active_scans[scan_id]['gobuster']['results'] = results
                
            finally:
                # Clean up temporary wordlist
                import os
                if os.path.exists(wordlist_path):
                    os.remove(wordlist_path)
                    
        except Exception as e:
            print(f"[ERROR] Gobuster scan failed: {e}")
            with self.lock:
                if scan_id in self.active_scans:
                    self.active_scans[scan_id]['gobuster']['status'] = 'error'
                    self.active_scans[scan_id]['gobuster']['error'] = str(e)
    
    def _run_nikto(self, scan_id: str, params: Dict):
        """Run Nikto scan on base URL"""
        try:
            with self.lock:
                self.active_scans[scan_id]['nikto']['status'] = 'running'
            
            scanner = NiktoScanner()
            
            # Ensure target_url has http:// or https:// prefix
            target_url = params.get('target_url')
            if not target_url.startswith('http://') and not target_url.startswith('https://'):
                target_url = 'http://' + target_url
            
            # Prepare Nikto parameters
            nikto_params = {
                'target_url': target_url,
                'scan_type': params.get('nikto', {}).get('scan_type', ''),
                'delay': params.get('nikto', {}).get('delay', '0'),
                'ssl_enforce': params.get('ssl_enforce', False),
                'recursive': params.get('nikto', {}).get('recursive', False)
            }
            
            # Callback for real-time updates
            def on_output(output_line):
                with self.lock:
                    if scan_id in self.active_scans:
                        self.active_scans[scan_id]['nikto']['output'].append(output_line)
            
            # Run scan
            output = scanner.scan(nikto_params, callback=on_output)
            
            with self.lock:
                if scan_id in self.active_scans:
                    self.active_scans[scan_id]['nikto']['status'] = 'completed'
                    self.active_scans[scan_id]['nikto']['output'] = output
                    
        except Exception as e:
            print(f"[ERROR] Nikto scan failed: {e}")
            with self.lock:
                if scan_id in self.active_scans:
                    self.active_scans[scan_id]['nikto']['status'] = 'error'
                    self.active_scans[scan_id]['nikto']['error'] = str(e)
    
    def _run_nikto_on_targets(self, scan_id: str, params: Dict, target_paths: List[str]):
        """
        Run Nikto on multiple targets (base URL + critical paths) using queue
        """
        try:
            with self.lock:
                self.active_scans[scan_id]['nikto']['status'] = 'running'
            
            scanner = NiktoScanner()
            base_url = params.get('target_url')
            
            # Ensure base_url has http:// or https:// prefix
            if not base_url.startswith('http://') and not base_url.startswith('https://'):
                base_url = 'http://' + base_url
            
            base_url = base_url.rstrip('/')
            
            # Build target list: base URL + critical paths
            targets = [base_url]
            for path in target_paths:
                targets.append(base_url + path)
            
            print(f"[INFO] ðŸŽ¯ Nikto will scan {len(targets)} targets:")
            for idx, target in enumerate(targets):
                print(f"  {idx+1}. {target}")
            
            all_output = []
            
            # Queue-based execution: scan each target sequentially
            for idx, target_url in enumerate(targets):
                print(f"[INFO] Nikto scanning target {idx+1}/{len(targets)}: {target_url}")
                
                # Add header to output
                header = {
                    'type': 'header',
                    'message': f'[*] Analyzing {target_url}...'
                }
                all_output.append(header)
                
                # Update real-time
                with self.lock:
                    if scan_id in self.active_scans:
                        self.active_scans[scan_id]['nikto']['output'].append(header)
                
                # Prepare Nikto parameters for this target
                nikto_params = {
                    'target_url': target_url,
                    'scan_type': params.get('nikto', {}).get('scan_type', ''),
                    'delay': params.get('nikto', {}).get('delay', '0'),
                    'ssl_enforce': params.get('ssl_enforce', False)
                }
                
                # Callback for real-time updates
                def on_output(output_line):
                    all_output.append(output_line)
                    with self.lock:
                        if scan_id in self.active_scans:
                            self.active_scans[scan_id]['nikto']['output'].append(output_line)
                
                # Run scan on this target
                output = scanner.scan(nikto_params, callback=on_output)
                
                # Small delay between targets to avoid overwhelming server
                if idx < len(targets) - 1:
                    time.sleep(2)
            
            with self.lock:
                if scan_id in self.active_scans:
                    self.active_scans[scan_id]['nikto']['status'] = 'completed'
                    self.active_scans[scan_id]['nikto']['output'] = all_output
                    
        except Exception as e:
            print(f"[ERROR] Nikto multi-target scan failed: {e}")
            with self.lock:
                if scan_id in self.active_scans:
                    self.active_scans[scan_id]['nikto']['status'] = 'error'
                    self.active_scans[scan_id]['nikto']['error'] = str(e)
    
    def get_scan_status(self, scan_id: str) -> Optional[Dict]:
        """Get current status of a scan"""
        with self.lock:
            return self.active_scans.get(scan_id)
    
    def cancel_scan(self, scan_id: str) -> bool:
        """Cancel a running scan"""
        with self.lock:
            scan_state = self.active_scans.get(scan_id)
            if not scan_state:
                return False
            
            if scan_state['status'] in ['completed', 'cancelled', 'error']:
                return False
            
            scan_state['status'] = 'cancelled'
            return True
    
    def cleanup_old_scans(self, max_age_seconds: int = 3600):
        """Remove scans older than max_age_seconds"""
        current_time = time.time()
        with self.lock:
            scan_ids_to_remove = []
            for scan_id, scan_state in self.active_scans.items():
                age = current_time - scan_state['created_at']
                if age > max_age_seconds:
                    scan_ids_to_remove.append(scan_id)
            
            for scan_id in scan_ids_to_remove:
                del self.active_scans[scan_id]
            
            if scan_ids_to_remove:
                print(f"[INFO] Cleaned up {len(scan_ids_to_remove)} old scans")
