"""
Nmap Scanner Module
Handles network scanning using Nmap with platform detection and result parsing.
"""

import subprocess
import platform
import shutil
import xml.etree.ElementTree as ET
from typing import Dict, List, Optional
import json
import os


class NmapScanner:
    """Nmap scanner with cross-platform support"""
    
    def __init__(self):
        self.platform = platform.system()
        self.nmap_path = self._find_nmap()
        
    def _find_nmap(self) -> Optional[str]:
        """Find Nmap executable on the system"""
        nmap_path = shutil.which('nmap')
        
        if nmap_path:
            print(f"[INFO] Nmap found at: {nmap_path}")
            return nmap_path
        
        # Try common installation paths
        common_paths = {
            'Windows': [
                r'C:\Program Files\Nmap\nmap.exe',
                r'C:\Program Files (x86)\Nmap\nmap.exe'
            ],
            'Linux': ['/usr/bin/nmap', '/usr/local/bin/nmap'],
            'Darwin': ['/usr/local/bin/nmap', '/opt/homebrew/bin/nmap']
        }
        
        for path in common_paths.get(self.platform, []):
            if os.path.exists(path):
                print(f"[INFO] Nmap found at: {path}")
                return path
        
        print("[ERROR] Nmap not found on system")
        return None
    
    def check_nmap_installed(self) -> bool:
        """Check if Nmap is installed and accessible"""
        if not self.nmap_path:
            return False
        
        try:
            result = subprocess.run(
                [self.nmap_path, '--version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            return result.returncode == 0
        except Exception as e:
            print(f"[ERROR] Failed to check Nmap: {e}")
            return False
    
    def build_nmap_command(self, params: Dict) -> List[str]:
        """
        Build Nmap command based on scan parameters
        
        Args:
            params: Dictionary with scan parameters
                - targets: IP range or hostname
                - scanType: 'host', 'temel-tcp', 'temel-udp'
                - portSelection: 'tcp-all', 'udp-all', 'custom-range', 'specific'
                - synScan: bool
                - versionScan: bool
                - osScan: bool
                - speed: 'paranoid', 'sneaky', 'polite', 'normal', 'aggressive', 'insane'
        
        Returns:
            List of command arguments
        """
        cmd = [self.nmap_path]
        
        # Scan type
        scan_type = params.get('scanType', 'host')
        
        if scan_type == 'host':
            # Host discovery only (no port scan)
            cmd.append('-sn')
        elif scan_type == 'temel-tcp':
            # TCP connect scan
            cmd.append('-sT')
        elif scan_type == 'temel-udp':
            # UDP scan
            cmd.append('-sU')
        
        # SYN scan (requires root/admin)
        if params.get('synScan') and scan_type != 'host':
            cmd.append('-sS')
        
        # Port selection (only if not host discovery)
        if scan_type != 'host':
            port_selection = params.get('portSelection')
            
            if port_selection == 'tcp-all':
                # Scan all TCP ports
                cmd.extend(['-p', '1-65535'])
            elif port_selection == 'udp-all':
                # Scan all UDP ports
                cmd.extend(['-p', '1-65535'])
            elif port_selection == 'custom-range':
                # Custom port range
                port_range = params.get('portRange', '1-1000')
                cmd.extend(['-p', port_range])
            elif port_selection == 'specific':
                # Specific ports
                ports = params.get('customPorts', '80,443,22')
                cmd.extend(['-p', ports])
            # else: No port specification = Nmap default (top 1000 ports)
        
        # Service version detection
        if params.get('versionScan'):
            cmd.append('-sV')
        
        # OS detection
        if params.get('osScan'):
            cmd.append('-O')
        
        # Timing template
        speed_map = {
            'paranoid': '-T0',
            'sneaky': '-T1',
            'polite': '-T2',
            'normal': '-T3',
            'aggressive': '-T4',
            'insane': '-T5'
        }
        speed = params.get('speed', 'normal')
        cmd.append(speed_map.get(speed, '-T3'))
        
        # Output format (XML for parsing)
        cmd.extend(['-oX', '-'])
        
        # Disable DNS resolution for faster scanning
        cmd.append('-n')
        
        # Target
        targets = params.get('targets', '127.0.0.1')
        cmd.append(targets)
        
        return cmd
    
    def run_scan(self, params: Dict, scan_id=None, active_scans=None) -> Dict:
        """
        Execute Nmap scan
        
        Args:
            params: Scan parameters
            scan_id: Optional scan ID for tracking
            active_scans: Optional dict to store process reference
        
        Returns:
            Dictionary with scan results or error
        """
        if not self.check_nmap_installed():
            return {
                'success': False,
                'error': 'Nmap is not installed or not accessible'
            }
        
        cmd = self.build_nmap_command(params)
        
        print(f"[INFO] Running command: {' '.join(cmd)}")
        
        # Determine timeout based on scan type
        scan_type = params.get('scanType', 'host')
        if scan_type == 'temel-udp':
            timeout = 1800  # 30 minutes for UDP
        elif params.get('portSelection') in ['tcp-all', 'udp-all']:
            timeout = 3600  # 60 minutes for full port scans
        else:
            timeout = 600   # 10 minutes for normal scans
        
        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            # Store process reference for cancellation
            if scan_id and active_scans:
                active_scans[scan_id]['process'] = process
                active_scans[scan_id]['devices'] = []
            
            # Read output line by line for real-time updates
            stdout_lines = []
            stderr_lines = []
            
            # Use non-blocking reads for real-time updates
            import select
            import sys
            
            # Collect all output
            while True:
                # Check if process is done
                if process.poll() is not None:
                    # Process finished, read remaining output
                    remaining_out, remaining_err = process.communicate()
                    if remaining_out:
                        stdout_lines.append(remaining_out)
                    if remaining_err:
                        stderr_lines.append(remaining_err)
                    break
                
                # Check if cancelled
                if scan_id and active_scans and active_scans[scan_id].get('status') == 'cancelled':
                    process.kill()
                    return {
                        'success': False,
                        'error': 'Tarama iptal edildi'
                    }
                
                # Read available output (non-blocking on Windows is tricky, so we use a simple approach)
                try:
                    import time
                    time.sleep(0.5)  # Small delay to avoid busy waiting
                    
                    # Try to read from stdout
                    line = process.stdout.readline()
                    if line:
                        stdout_lines.append(line)
                        
                        # Try to parse partial results for real-time updates
                        if scan_id and active_scans and '<host' in line:
                            # Found a host, try to parse incrementally
                            try:
                                # Accumulate XML and try to parse
                                current_xml = ''.join(stdout_lines)
                                if '</host>' in current_xml:
                                    # Try to extract and parse completed host entries
                                    partial_devices = self._parse_partial_xml(current_xml)
                                    if partial_devices:
                                        active_scans[scan_id]['devices'] = partial_devices
                            except:
                                pass  # Ignore parsing errors during incremental updates
                    
                except:
                    pass
            
            stdout = ''.join(stdout_lines)
            stderr = ''.join(stderr_lines)
            
            # Check if cancelled
            if scan_id and active_scans and active_scans[scan_id].get('status') == 'cancelled':
                return {
                    'success': False,
                    'error': 'Tarama iptal edildi'
                }
            
            # Check for UDP warnings
            warning = None
            if stderr and scan_type == 'temel-udp':
                stderr_lower = stderr.lower()
                if 'retransmission cap' in stderr_lower or 'giving up' in stderr_lower:
                    warning = 'UDP taraması ağ koşulları nedeniyle yavaş. Bazı portlar atlanmış olabilir.'
                    print(f"[WARNING] UDP scan warning: {stderr}")
            
            if process.returncode == 0:
                # Parse XML output
                devices = self.parse_nmap_xml(stdout)
                result = {
                    'success': True,
                    'devices': devices,
                    'raw_output': stdout
                }
                if warning:
                    result['warning'] = warning
                return result
            else:
                return {
                    'success': False,
                    'error': stderr or 'Scan failed'
                }
        
        except Exception as e:
            return {
                'success': False,
                'error': f'Scan error: {str(e)}'
            }
    
    def _parse_partial_xml(self, xml_text: str) -> List[Dict]:
        """Parse partial XML for real-time updates"""
        try:
            # Wrap in nmaprun tags if not present
            if '<nmaprun' not in xml_text:
                xml_text = '<?xml version="1.0"?><nmaprun>' + xml_text + '</nmaprun>'
            
            # Try to parse
            devices = self.parse_nmap_xml(xml_text)
            return devices
        except:
            return []
    
    def parse_nmap_xml(self, xml_output: str) -> List[Dict]:
        """
        Parse Nmap XML output
        
        Returns:
            List of device dictionaries
        """
        devices = []
        
        try:
            root = ET.fromstring(xml_output)
            
            for host in root.findall('host'):
                # Check if host is up
                status = host.find('status')
                if status is None or status.get('state') != 'up':
                    continue
                
                device = {}
                
                # IP Address
                address = host.find('address')
                if address is not None:
                    device['ip'] = address.get('addr')
                
                # Hostname
                hostnames = host.find('hostnames')
                if hostnames is not None:
                    hostname = hostnames.find('hostname')
                    if hostname is not None:
                        device['hostname'] = hostname.get('name')
                    else:
                        device['hostname'] = device.get('ip', 'Unknown')
                else:
                    device['hostname'] = device.get('ip', 'Unknown')
                
                # OS Detection
                os_info = host.find('os')
                device['os'] = 'Unknown'
                if os_info is not None:
                    osmatch = os_info.find('osmatch')
                    if osmatch is not None:
                        device['os'] = osmatch.get('name', 'Unknown')
                
                # Device type detection
                device['device_type'] = self.detect_device_type(
                    device.get('os', ''),
                    device.get('hostname', '')
                )
                
                # Ports
                ports_elem = host.find('ports')
                device['ports'] = []
                device['vulnerabilities'] = {
                    'critical': 0,
                    'medium': 0,
                    'low': 0
                }
                
                if ports_elem is not None:
                    for port in ports_elem.findall('port'):
                        state = port.find('state')
                        if state is not None and state.get('state') == 'open':
                            port_info = {
                                'port': port.get('portid'),
                                'protocol': port.get('protocol'),
                                'state': 'open'
                            }
                            
                            # Service info
                            service = port.find('service')
                            if service is not None:
                                port_info['service'] = service.get('name', 'unknown')
                                port_info['version'] = service.get('version', '')
                                port_info['product'] = service.get('product', '')
                            
                            device['ports'].append(port_info)
                
                devices.append(device)
        
        except ET.ParseError as e:
            print(f"[ERROR] XML parsing error: {e}")
        
        return devices
    
    def detect_device_type(self, os_info: str, hostname: str) -> str:
        """
        Detect device type based on OS and hostname
        
        Returns:
            Device type string (linux, windows, router, etc.)
        """
        os_lower = os_info.lower()
        host_lower = hostname.lower()
        
        if 'linux' in os_lower or 'linux' in host_lower:
            return 'linux'
        elif 'windows' in os_lower or 'windows' in host_lower:
            return 'windows'
        elif 'router' in host_lower or 'gateway' in host_lower:
            return 'router'
        elif 'cisco' in os_lower or 'switch' in host_lower:
            return 'switch'
        elif 'apple' in os_lower or 'mac' in os_lower or 'darwin' in os_lower:
            return 'apple'
        elif 'android' in os_lower:
            return 'android'
        else:
            return 'unknown'


# Example usage
if __name__ == '__main__':
    scanner = NmapScanner()
    
    # Check if Nmap is installed
    if scanner.check_nmap_installed():
        print("[OK] Nmap is ready")
        
        # Example scan
        params = {
            'targets': '127.0.0.1',
            'scanType': 'temel-tcp',
            'portSelection': 'specific',
            'customPorts': '80,443,22',
            'versionScan': True,
            'osScan': False,
            'speed': 'normal'
        }
        
        result = scanner.run_scan(params)
        print(json.dumps(result, indent=2))
    else:
        print("[ERROR] Nmap is not installed")
