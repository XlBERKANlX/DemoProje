import os
from dotenv import load_dotenv
from groq import Groq
import json
from collections import defaultdict
import re

# Load environment variables
load_dotenv()

class AIAnalyzer:
    def __init__(self):
        self.api_key = os.getenv('GROQ_API_KEY')
        self.model_name = os.getenv('GROQ_MODEL', 'llama-3.1-70b-versatile')
        
        if not self.api_key:
            print("[ERROR] Groq API Key not found in environment variables")
            return
            
        try:
            # Initialize Groq client
            self.client = Groq(api_key=self.api_key)
            print(f"[INFO] AI Analyzer initialized with Groq model: {self.model_name}")
        except Exception as e:
            print(f"[ERROR] Failed to initialize Groq AI: {e}")

    def analyze_device(self, device_data):
        """
        Analyze device scan results using Groq AI
        """
        if not self.api_key:
            return {"error": "API Key not configured"}

        # Check if we need batch analysis
        if 'ports' in device_data and len(device_data['ports']) > 5:
            print(f"[INFO] Device has {len(device_data['ports'])} ports. Using batch analysis...")
            
            # Sort ports for batch analysis
            priority_services = ['http', 'https', 'ssh', 'ftp', 'telnet', 'smtp', 'mysql', 
                                'postgresql', 'rdp', 'vnc', 'smb', 'nfs', 'rpcbind']
            sorted_ports = sorted(device_data['ports'], 
                                key=lambda p: (p.get('service', '').lower() not in priority_services, 
                                             p.get('port', 99999)))
            
            return self._batch_analysis(device_data, sorted_ports, batch_size=5)
        
        # Normal single analysis
        prompt = self._build_device_analysis_prompt(device_data)
        
        try:
            import time
            start_time = time.time()
            
            # Call Groq API
            chat_completion = self.client.chat.completions.create(
                messages=[
                    {
                        "role": "system",
                        "content": "You are a cybersecurity expert analyzing network scan results. Return only valid JSON."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                model=self.model_name,
                temperature=0.5,
                max_tokens=4096,
                top_p=0.9,
            )
            
            elapsed = time.time() - start_time
            print(f"[INFO] AI analysis completed in {elapsed:.2f} seconds")
            
            # Parse JSON from response
            result = self._parse_json_response(chat_completion.choices[0].message.content)
            return result
            
        except Exception as e:
            error_msg = str(e)
            print(f"[ERROR] AI Analysis failed: {error_msg}")
            return {"error": error_msg}

    def _build_device_analysis_prompt(self, device, force_single=False):
        """Build prompt for device analysis"""
        
        # Format ports and services in compact format
        ports_info = []
        if 'ports' in device:
            priority_services = ['http', 'https', 'ssh', 'ftp', 'telnet', 'smtp', 'mysql', 
                                'postgresql', 'rdp', 'vnc', 'smb', 'nfs', 'rpcbind']
            
            sorted_ports = sorted(device['ports'], 
                                key=lambda p: (p.get('service', '').lower() not in priority_services, 
                                             p.get('port', 99999)))
            
            for p in sorted_ports:
                service = p.get('service', 'unknown')
                version = p.get('version', '')
                if version:
                    ports_info.append(f"{p['port']}/{p['protocol']}: {service} {version}")
                else:
                    ports_info.append(f"{p['port']}/{p['protocol']}: {service}")
        
        ports_text = "\n".join(ports_info) if ports_info else "No open ports"
        
        prompt = f"""Analyze {device.get('ip')} for CVEs. Return valid JSON only.

Services:
{ports_text}

Return this exact JSON structure:
{{
  "summary": "Brief 1-2 sentence summary of security posture",
  "risk_score": 9.5,
  "risk_level": "Critical",
  "vulnerabilities": [
    {{
      "title": "CVE-2023-1234 (80)",
      "severity": "High",
      "cvss_score": 7.5,
      "description": "Brief 2-3 sentence description of vulnerability and impact",
      "affected_port": 80
    }}
  ],
  "recommendations": ["Update service to latest version", "Disable if not needed"]
}}

STRICT RULES:
1. Max 4 CVEs per port (newest only)
2. Description: 2-3 sentences (not too long)
3. Recommendations: Short actionable items
4. NO markdown code blocks
5. NO explanations outside JSON
6. Complete ALL fields before stopping
"""
        return prompt
    
    def _batch_analysis(self, device, sorted_ports, batch_size):
        """
        Analyze device in batches when there are too many ports
        Returns combined analysis results
        """
        import math
        import time
        
        num_batches = math.ceil(len(sorted_ports) / batch_size)
        all_vulnerabilities = []
        all_recommendations = set()
        max_risk_score = 0
        summaries = []
        
        print(f"[INFO] Splitting {len(sorted_ports)} ports into {num_batches} batches")
        
        for batch_num in range(num_batches):
            start_idx = batch_num * batch_size
            end_idx = min((batch_num + 1) * batch_size, len(sorted_ports))
            batch_ports = sorted_ports[start_idx:end_idx]
            
            print(f"[INFO] Analyzing batch {batch_num + 1}/{num_batches} ({len(batch_ports)} ports)")
            
            # Create temporary device data for this batch
            batch_device = device.copy()
            batch_device['ports'] = batch_ports
            
            # Build prompt for this batch
            prompt = self._build_device_analysis_prompt(batch_device, force_single=True)
            
            # Analyze this batch
            try:
                # Call Groq API
                chat_completion = self.client.chat.completions.create(
                    messages=[
                        {
                            "role": "system",
                            "content": "You are a cybersecurity expert analyzing network scan results. Return only valid JSON."
                        },
                        {
                            "role": "user",
                            "content": prompt
                        }
                    ],
                    model=self.model_name,
                    temperature=0.5,
                    max_tokens=4096,
                    top_p=0.9,
                )
                
                response_text = chat_completion.choices[0].message.content
                print(f"[DEBUG] Batch {batch_num + 1} raw response length: {len(response_text)}")
                
                result = self._parse_json_response(response_text)
                
                print(f"[DEBUG] Batch {batch_num + 1} parsed result keys: {result.keys()}")
                
                if 'error' in result:
                    print(f"[WARNING] Batch {batch_num + 1} returned error: {result.get('error')}")
                    continue
                
                if 'vulnerabilities' in result:
                    vuln_count = len(result['vulnerabilities'])
                    all_vulnerabilities.extend(result['vulnerabilities'])
                    print(f"[INFO] Batch {batch_num + 1} found {vuln_count} vulnerabilities")
                
                if 'recommendations' in result:
                    rec_count = len(result['recommendations'])
                    all_recommendations.update(result['recommendations'])
                    print(f"[INFO] Batch {batch_num + 1} has {rec_count} recommendations")
                
                if 'risk_score' in result:
                    batch_risk = float(result.get('risk_score', 0))
                    max_risk_score = max(max_risk_score, batch_risk)
                    print(f"[INFO] Batch {batch_num + 1} risk score: {batch_risk}")
                
                if 'summary' in result:
                    summaries.append(result['summary'])
                
                # Small delay between batches (Groq allows 30/min, so ~2s is safe)
                if batch_num < num_batches - 1:
                    time.sleep(2)
                    
            except Exception as e:
                print(f"[ERROR] Batch {batch_num + 1} analysis failed: {e}")
                import traceback
                traceback.print_exc()
                continue
        
        print(f"[INFO] Batch analysis complete. Total vulnerabilities: {len(all_vulnerabilities)}, Total recommendations: {len(all_recommendations)}")
        
        # Filter vulnerabilities: max 4 per port, prioritize newest CVEs
        filtered_vulns = self._filter_vulnerabilities_by_port(all_vulnerabilities)
        print(f"[INFO] After filtering (max 4 per port): {len(filtered_vulns)} vulnerabilities")
        
        # Combine results
        combined_summary = f"Analysis of {len(sorted_ports)} ports across {num_batches} batches. " + " ".join(summaries[:2])
        
        # Determine risk level
        if max_risk_score >= 9.0:
            risk_level = "Critical"
        elif max_risk_score >= 7.0:
            risk_level = "High"
        elif max_risk_score >= 4.0:
            risk_level = "Medium"
        else:
            risk_level = "Low"
        
        return {
            "summary": combined_summary,
            "risk_score": max_risk_score,
            "risk_level": risk_level,
            "vulnerabilities": filtered_vulns,
            "recommendations": list(all_recommendations)
        }
    
    def _filter_vulnerabilities_by_port(self, vulnerabilities):
        """
        Filter vulnerabilities to max 4 per port, prioritizing newest CVEs
        """
        port_vulns = defaultdict(list)
        for vuln in vulnerabilities:
            port = vuln.get('affected_port', 'unknown')
            port_vulns[port].append(vuln)
        
        filtered = []
        for port, vulns in port_vulns.items():
            def get_cve_year(vuln):
                title = vuln.get('title', '')
                match = re.search(r'CVE-(\d{4})', title)
                if match:
                    return int(match.group(1))
                return 0
            
            sorted_vulns = sorted(vulns, key=get_cve_year, reverse=True)
            filtered.extend(sorted_vulns[:4])
        
        return filtered

    def _parse_json_response(self, text):
        """Clean and parse JSON response"""
        try:
            # Remove markdown formatting if present
            clean_text = text.replace('```json', '').replace('```', '').strip()
            
            # Try to parse JSON
            parsed = json.loads(clean_text)
            
            # Validate required keys
            if 'summary' not in parsed or 'risk_score' not in parsed:
                print(f"[WARNING] AI response missing required keys. Keys found: {parsed.keys()}")
            
            return parsed
            
        except json.JSONDecodeError as e:
            print(f"[ERROR] Failed to parse JSON response: {e}")
            print(f"[DEBUG] Raw response (first 500 chars): {text[:500]}")
            
            return {
                "error": "Could not parse AI response as JSON",
                "summary": "AI returned invalid JSON format",
                "risk_score": 0,
                "risk_level": "Unknown",
                "vulnerabilities": [],
                "recommendations": [],
                "raw_response": text[:1000]
            }

if __name__ == '__main__':
    analyzer = AIAnalyzer()
    test_device = {
        'ip': '192.168.1.1',
        'ports': [
            {'port': 80, 'protocol': 'tcp', 'service': 'http', 'version': 'Apache 2.4.41'},
            {'port': 22, 'protocol': 'tcp', 'service': 'ssh', 'version': 'OpenSSH 7.2'}
        ]
    }
    print(analyzer.analyze_device(test_device))
