"""
Nikto Scanner Module
Handles vulnerability scanning using Nikto
"""

import subprocess
import os
import shutil
from typing import Dict, List, Optional, Callable
import re

class NiktoScanner:
    def __init__(self):
        self.nikto_path = self.find_nikto()
        self.process = None
        self.is_cancelled = False
        
    def find_nikto(self) -> Optional[str]:
        """
        Find Nikto executable in system PATH
        """
        # Try to find nikto in PATH
        nikto_path = shutil.which('nikto')
        
        if nikto_path:
            print(f"[INFO] Nikto found at: {nikto_path}")
            return nikto_path
        
        # Common installation paths
        common_paths = [
            '/usr/bin/nikto',
            '/usr/local/bin/nikto',
            '/opt/nikto/nikto.pl',
            '/usr/share/nikto/nikto.pl'
        ]
        
        for path in common_paths:
            if os.path.isfile(path) and os.access(path, os.X_OK):
                print(f"[INFO] Nikto found at: {path}")
                return path
        
        print("[WARNING] Nikto not found in system")
        return None
    
    def build_command(self, params: Dict) -> List[str]:
        """
        Build Nikto command based on parameters
        
        Args:
            params: {
                'target_url': 'https://example.com',
                'scan_type': '2',  # 0-9, a-c
                'delay': '0',  # seconds
                'ssl_enforce': True
            }
        """
        if not self.nikto_path:
            raise Exception("Nikto executable not found")
        
        cmd = [self.nikto_path]
        
        # Target URL
        target_url = params.get('target_url', '')
        if not target_url:
            raise ValueError("Target URL is required")
        
        cmd.extend(['-h', target_url])
        
        # Scan type (Tuning)
        scan_type = params.get('scan_type', '')
        if scan_type:
            # Validate scan type
            valid_types = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c']
            if scan_type.lower() in valid_types:
                cmd.extend(['-Tuning', scan_type])
        
        # Delay between requests
        delay = params.get('delay', '0')
        try:
            delay_int = int(delay)
            if delay_int > 0:
                cmd.extend(['-Pause', str(delay_int)])
        except ValueError:
            pass
        
        # SSL options
        if params.get('ssl_enforce', False):
            cmd.append('-ssl')  # Force SSL
        
        # Output options
        cmd.extend([
            '-Format', 'txt',  # Text output
            '-nointeractive',  # Don't ask for user input
            '-Display', 'V',  # Verbose output
        ])
        
        return cmd
    
    def parse_output_line(self, line: str) -> Optional[Dict]:
        """
        Parse a single line of Nikto output
        
        Returns dict with 'type' and 'message'
        Types: 'header', 'success', 'info', 'warning', 'error'
        """
        line = line.strip()
        
        if not line:
            return None
        
        # Detect line type based on content
        result = {
            'type': 'info',
            'message': line
        }
        
        # Header lines (Target, Server, etc.)
        if line.startswith('+ Target'):
            result['type'] = 'header'
            result['message'] = line[2:].strip()  # Remove "+ "
        elif line.startswith('+ Server:'):
            result['type'] = 'header'
            result['message'] = line[2:].strip()
        elif line.startswith('+ IP:'):
            result['type'] = 'header'
            result['message'] = line[2:].strip()
        
        # Success findings (usually start with +)
        elif line.startswith('+ ') and any(keyword in line.lower() for keyword in ['found', 'retrieved', 'identified']):
            result['type'] = 'success'
            result['message'] = line[2:].strip()
        
        # Warnings (OSVDB, CVE references, or security issues)
        elif 'OSVDB' in line or 'CVE-' in line or any(keyword in line.lower() for keyword in ['vulnerable', 'exploit', 'weakness']):
            result['type'] = 'warning'
            result['message'] = line[2:].strip() if line.startswith('+ ') else line
        
        # Errors
        elif 'ERROR' in line.upper() or 'FAIL' in line.upper():
            result['type'] = 'error'
            result['message'] = line[2:].strip() if line.startswith('+ ') else line
        
        # Critical findings
        elif any(keyword in line.lower() for keyword in ['critical', 'high risk', 'dangerous']):
            result['type'] = 'critical'
            result['message'] = line[2:].strip() if line.startswith('+ ') else line
        
        # Info lines
        elif line.startswith('+ '):
            result['type'] = 'info'
            result['message'] = line[2:].strip()
        
        # Skip progress indicators and empty lines
        elif line.startswith('-') or line.startswith('=') or 'Testing:' in line:
            return None
        
        return result
    
    def scan(self, params: Dict, callback: Optional[Callable] = None) -> List[Dict]:
        """
        Execute Nikto scan
        
        Args:
            params: Scan parameters
            callback: Function to call for each output line (real-time updates)
        
        Returns:
            List of scan output lines
        """
        if not self.nikto_path:
            raise Exception("Nikto not available")
        
        self.is_cancelled = False
        output_lines = []
        
        try:
            cmd = self.build_command(params)
            print(f"[INFO] Executing Nikto: {' '.join(cmd)}")
            
            # Start process
            self.process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,  # Combine stderr with stdout
                text=True,
                bufsize=1
            )
            
            # Read output line by line
            for line in self.process.stdout:
                if self.is_cancelled:
                    self.process.terminate()
                    break
                
                result = self.parse_output_line(line)
                if result:
                    output_lines.append(result)
                    if callback:
                        callback(result)
            
            # Wait for process to complete
            self.process.wait()
            
            if self.is_cancelled:
                print("[INFO] Nikto scan cancelled")
            else:
                print(f"[INFO] Nikto scan completed. {len(output_lines)} output lines")
            
            return output_lines
            
        except Exception as e:
            print(f"[ERROR] Nikto scan failed: {e}")
            raise
        finally:
            self.process = None
    
    def cancel(self):
        """Cancel running scan"""
        self.is_cancelled = True
        if self.process:
            try:
                self.process.terminate()
                self.process.wait(timeout=5)
            except:
                self.process.kill()
