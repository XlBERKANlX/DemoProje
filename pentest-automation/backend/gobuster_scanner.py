"""
Gobuster Scanner Module
Handles directory/file enumeration using Gobuster
"""

import subprocess
import os
import shutil
import tempfile
from typing import Dict, List, Optional, Callable
import re
import threading

class GobusterScanner:
    def __init__(self):
        self.gobuster_path = self.find_gobuster()
        self.process = None
        self.is_cancelled = False
        
    def find_gobuster(self) -> Optional[str]:
        """
        Find Gobuster executable in system PATH
        """
        # Try to find gobuster in PATH
        gobuster_path = shutil.which('gobuster')
        
        if gobuster_path:
            print(f"[INFO] Gobuster found at: {gobuster_path}")
            return gobuster_path
        
        # Common installation paths
        common_paths = [
            '/usr/bin/gobuster',
            '/usr/local/bin/gobuster',
            '/opt/gobuster/gobuster'
        ]
        
        for path in common_paths:
            if os.path.isfile(path) and os.access(path, os.X_OK):
                print(f"[INFO] Gobuster found at: {path}")
                return path
        
        print("[WARNING] Gobuster not found in system")
        return None
    
    def build_command(self, params: Dict) -> List[str]:
        """
        Build Gobuster command based on parameters
        
        Args:
            params: {
                'target_url': 'https://example.com',
                'wordlist_path': '/path/to/wordlist.txt',
                'threads': '10',
                'delay': '0',
                'ssl_enforce': True
            }
        """
        if not self.gobuster_path:
            raise Exception("Gobuster executable not found")
        
        cmd = [self.gobuster_path, 'dir']
        
        # Target URL
        target_url = params.get('target_url', '')
        if not target_url:
            raise ValueError("Target URL is required")
        
        cmd.extend(['-u', target_url])
        
        # Wordlist
        wordlist_path = params.get('wordlist_path')
        if not wordlist_path or not os.path.isfile(wordlist_path):
            raise ValueError("Valid wordlist file is required")
        
        cmd.extend(['-w', wordlist_path])
        
        # Threads
        threads = params.get('threads', '10')
        try:
            threads_int = int(threads)
            if 1 <= threads_int <= 100:
                cmd.extend(['-t', str(threads_int)])
        except ValueError:
            pass  # Use default
        
        # Delay (convert ms to duration format)
        delay = params.get('delay', '0')
        try:
            delay_int = int(delay)
            if delay_int > 0:
                # Gobuster uses duration format (e.g., "100ms")
                cmd.extend(['--delay', f'{delay_int}ms'])
        except ValueError:
            pass
        
        # SSL/TLS options
        if params.get('ssl_enforce', False):
            cmd.append('-k')  # Skip SSL certificate verification
        
        # Output options
        cmd.extend([
            '-q',  # Quiet mode (less verbose)
            '--no-error',  # Don't display errors
        ])
        
        return cmd
    
    def parse_output_line(self, line: str) -> Optional[Dict]:
        """
        Parse a single line of Gobuster output
        
        Example output:
        /admin                (Status: 200) [Size: 4096]
        /login.php            (Status: 200) [Size: 2048]
        /api                  (Status: 301) [Size: 0] [--> /api/]
        """
        line = line.strip()
        
        if not line or line.startswith('['):
            return None
        
        # Regex to parse Gobuster output
        # Pattern: /path (Status: XXX) [Size: YYYY]
        pattern = r'^(/[^\s]*)\s+\(Status:\s+(\d+)\)\s+\[Size:\s+(\d+)\]'
        match = re.match(pattern, line)
        
        if match:
            path = match.group(1)
            status = int(match.group(2))
            size_bytes = int(match.group(3))
            
            # Determine type (directory or file)
            item_type = "Directory" if path.endswith('/') else "File"
            
            # Format size
            size_str = self.format_size(size_bytes)
            
            return {
                'path': path,
                'status': status,
                'size': size_str,
                'type': item_type
            }
        
        return None
    
    def format_size(self, size_bytes: int) -> str:
        """Format size in bytes to human-readable format"""
        if size_bytes == 0:
            return "0 B"
        elif size_bytes < 1024:
            return f"{size_bytes} B"
        elif size_bytes < 1024 * 1024:
            return f"{size_bytes / 1024:.1f} KB"
        else:
            return f"{size_bytes / (1024 * 1024):.1f} MB"
    
    def scan(self, params: Dict, callback: Optional[Callable] = None) -> List[Dict]:
        """
        Execute Gobuster scan
        
        Args:
            params: Scan parameters
            callback: Function to call for each result (real-time updates)
        
        Returns:
            List of discovered paths
        """
        if not self.gobuster_path:
            raise Exception("Gobuster not available")
        
        self.is_cancelled = False
        results = []
        
        try:
            cmd = self.build_command(params)
            print(f"[INFO] Executing Gobuster: {' '.join(cmd)}")
            
            # Start process
            self.process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1
            )
            
            # Read output line by line
            for line in self.process.stdout:
                if self.is_cancelled:
                    self.process.terminate()
                    break
                
                result = self.parse_output_line(line)
                if result:
                    results.append(result)
                    if callback:
                        callback(result)
            
            # Wait for process to complete
            self.process.wait()
            
            if self.is_cancelled:
                print("[INFO] Gobuster scan cancelled")
            else:
                print(f"[INFO] Gobuster scan completed. Found {len(results)} items")
            
            return results
            
        except Exception as e:
            print(f"[ERROR] Gobuster scan failed: {e}")
            raise
        finally:
            self.process = None
    
    def cancel(self):
        """Cancel running scan"""
        self.is_cancelled = True
        if self.process:
            try:
                self.process.terminate()
                self.process.wait(timeout=5)
            except:
                self.process.kill()
    
    def create_wordlist_file(self, wordlist_content: str) -> str:
        """
        Create temporary wordlist file from string content
        
        Args:
            wordlist_content: Wordlist paths separated by newlines
        
        Returns:
            Path to temporary wordlist file
        """
        # Create temp file
        fd, temp_path = tempfile.mkstemp(suffix='.txt', prefix='gobuster_wordlist_')
        
        try:
            with os.fdopen(fd, 'w') as f:
                # Write each line, ensuring it starts with /
                for line in wordlist_content.strip().split('\n'):
                    line = line.strip()
                    if line:
                        if not line.startswith('/'):
                            line = '/' + line
                        f.write(line + '\n')
            
            print(f"[INFO] Created temporary wordlist: {temp_path}")
            return temp_path
            
        except Exception as e:
            os.close(fd)
            if os.path.exists(temp_path):
                os.remove(temp_path)
            raise Exception(f"Failed to create wordlist file: {e}")
