// Radio Button Logic - Host Discovery vs Port Selection
const scanTypeRadios = document.querySelectorAll('input[name="scan-type"]');
const portSelectionRadios = document.querySelectorAll('input[name="port-selection"]');

// Add toggle functionality to radio buttons (click again to deselect)
function makeRadioToggleable(radioButtons) {
    radioButtons.forEach(radio => {
        radio.addEventListener('click', function (e) {
            // If already checked, uncheck it
            if (this.dataset.wasChecked === 'true') {
                this.checked = false;
                this.dataset.wasChecked = 'false';
                // Trigger change event to update dependent states
                this.dispatchEvent(new Event('change'));
            } else {
                // Mark all radios in this group as unchecked
                radioButtons.forEach(r => r.dataset.wasChecked = 'false');
                // Mark this one as checked
                this.dataset.wasChecked = 'true';
            }
        });
    });
}

// Apply toggle functionality to both radio groups
makeRadioToggleable(scanTypeRadios);
makeRadioToggleable(portSelectionRadios);

function updatePortSelectionState() {
    const hostDiscoveryRadio = document.querySelector('input[name="scan-type"][value="host"]');
    const hostDiscoverySelected = hostDiscoveryRadio?.checked;

    portSelectionRadios.forEach(radio => {
        if (hostDiscoverySelected) {
            // Disable port selection when Host Discovery is selected
            radio.disabled = true;
            radio.checked = false;
            radio.dataset.wasChecked = 'false';
            radio.parentElement.style.opacity = '0.5';
            radio.parentElement.style.cursor = 'not-allowed';
        } else {
            // Enable port selection for other scan types
            radio.disabled = false;
            radio.parentElement.style.opacity = '1';
            radio.parentElement.style.cursor = 'pointer';
        }
    });
}

// When port selection is made, auto-deselect host discovery
portSelectionRadios.forEach(radio => {
    radio.addEventListener('change', () => {
        if (radio.checked) {
            const hostDiscoveryRadio = document.querySelector('input[name="scan-type"][value="host"]');
            if (hostDiscoveryRadio && hostDiscoveryRadio.checked) {
                hostDiscoveryRadio.checked = false;
                hostDiscoveryRadio.dataset.wasChecked = 'false';
                updatePortSelectionState();
            }
        }
    });
});

// Listen to scan type changes
scanTypeRadios.forEach(radio => {
    radio.addEventListener('change', updatePortSelectionState);
});

// Initialize on page load - port options enabled by default
updatePortSelectionState();

// AI Analysis Panel Toggle
const aiToggleBtn = document.getElementById('aiToggleBtn');
const aiAnalysisPanel = document.getElementById('aiAnalysisPanel');

aiToggleBtn.addEventListener('click', () => {
    aiAnalysisPanel.classList.toggle('open');
    aiToggleBtn.classList.toggle('active');
});

// Device Selection
const deviceItems = document.querySelectorAll('.device-item');
deviceItems.forEach(device => {
    device.addEventListener('click', () => {
        // Remove selected class from all devices
        deviceItems.forEach(d => d.classList.remove('device-selected'));
        // Add selected class to clicked device
        device.classList.add('device-selected');

        // Update technical details (placeholder - will be dynamic with backend)
        const deviceName = device.querySelector('.device-name').textContent;
        document.querySelector('.details-header').textContent = `Teknik Detaylar: ${deviceName}`;
    });
});

// Vulnerability Item Selection
const vulnItems = document.querySelectorAll('.vuln-item');
const cveSeverityCard = document.getElementById('cveSeverityCard');

vulnItems.forEach(item => {
    item.addEventListener('click', () => {
        // Remove selected class from all items
        vulnItems.forEach(v => v.classList.remove('vuln-selected'));
        // Add selected class to clicked item
        item.classList.add('vuln-selected');

        // Update CVE details (placeholder - will be dynamic with backend)
        const vulnText = item.textContent.trim();
        document.querySelector('.cve-header').textContent = vulnText;

        // Update CVE severity card color based on vulnerability type
        if (cveSeverityCard) {
            // Remove all severity classes
            cveSeverityCard.classList.remove('cve-card-critical', 'cve-card-medium', 'cve-card-low');

            // Add appropriate class based on selected vulnerability
            if (item.classList.contains('vuln-critical')) {
                cveSeverityCard.classList.add('cve-card-critical');
            } else if (item.classList.contains('vuln-medium')) {
                cveSeverityCard.classList.add('cve-card-medium');
            } else if (item.classList.contains('vuln-low')) {
                cveSeverityCard.classList.add('cve-card-low');
            } else {
                // Default to critical for general overview
                cveSeverityCard.classList.add('cve-card-critical');
            }
        }
    });
});

// Filter Buttons
const filterBtns = document.querySelectorAll('.filter-btn');
filterBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        // Remove active class from all filters
        filterBtns.forEach(b => b.classList.remove('filter-active'));
        // Add active class to clicked filter
        btn.classList.add('filter-active');

        // Filter logic will be implemented with backend data
        console.log('Filter clicked:', btn.textContent);
    });
});

// Start Scan Button - BACKEND INTEGRATION
const startScanBtn = document.querySelector('.btn-start-scan');
const devicesList = document.querySelector('.devices-list');
let currentScanId = null;
let pollInterval = null;
let isScanning = false;

startScanBtn.addEventListener('click', async () => {
    // If scanning, cancel the scan
    if (isScanning) {
        await cancelScan();
        return;
    }

    // Collect scan parameters
    const targets = document.querySelector('.input-field').value;

    if (!targets) {
        alert('L√ºtfen tarama hedefi girin (√∂rn: 10.0.2.5 veya 10.0.2.0/24)');
        return;
    }

    const scanParams = {
        targets: targets,
        scanType: document.querySelector('input[name="scan-type"]:checked')?.value || 'host',
        portSelection: document.querySelector('input[name="port-selection"]:checked')?.value,
        synScan: document.querySelector('input[name="syn-scan"]')?.checked || false,
        versionScan: document.querySelector('input[name="version-scan"]')?.checked || false,
        osScan: document.querySelector('input[name="os-scan"]')?.checked || false,
        speed: document.querySelector('.select-field')?.value || 'normal'
    };

    console.log('Starting scan with parameters:', scanParams);

    try {
        // Change button to cancel mode
        isScanning = true;
        startScanBtn.classList.add('scanning');
        startScanBtn.textContent = 'ƒ∞ptal Et';

        // Clear previous results
        devicesList.innerHTML = '<div style="color: #CCD6F6; padding: 20px;">Tarama ba≈ülatƒ±lƒ±yor...</div>';

        // Start scan
        const response = await fetch('/api/scan/start', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(scanParams)
        });

        const data = await response.json();

        if (data.success) {
            currentScanId = data.scan_id;
            devicesList.innerHTML = '<div style="color: #CCD6F6; padding: 20px;">‚è≥ Tarama devam ediyor...</div>';

            // Start polling for results
            pollScanStatus(currentScanId);
        } else {
            throw new Error(data.error || 'Tarama ba≈ülatƒ±lamadƒ±');
        }
    } catch (error) {
        console.error('Scan error:', error);
        alert(`Hata: ${error.message}`);
        resetScanButton();
        devicesList.innerHTML = '<div style="color: #F50000; padding: 20px;">‚ùå Tarama ba≈ülatƒ±lamadƒ±: ' + error.message + '</div>';
    }
});

// Cancel scan function
async function cancelScan() {
    if (!currentScanId) return;

    try {
        const response = await fetch(`/api/scan/cancel/${currentScanId}`, {
            method: 'POST'
        });

        const data = await response.json();

        if (data.success) {
            devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">‚ö†Ô∏è Tarama iptal edildi</div>';
        } else {
            alert(`ƒ∞ptal hatasƒ±: ${data.error}`);
        }
    } catch (error) {
        console.error('Cancel error:', error);
        alert(`ƒ∞ptal hatasƒ±: ${error.message}`);
    } finally {
        resetScanButton();
        if (pollInterval) {
            clearInterval(pollInterval);
        }
    }
}

// Reset scan button to initial state
function resetScanButton() {
    isScanning = false;
    startScanBtn.classList.remove('scanning');
    startScanBtn.textContent = 'Taramayƒ± Ba≈ülat';
    startScanBtn.disabled = false;
}

// Poll scan status and results
function pollScanStatus(scanId) {
    // Clear any existing interval
    if (pollInterval) {
        clearInterval(pollInterval);
    }

    // Poll every 2 seconds
    pollInterval = setInterval(async () => {
        try {
            const response = await fetch(`/api/scan/status/${scanId}`);
            const data = await response.json();

            if (data.success) {
                const status = data.status;

                if (status === 'completed') {
                    // Scan completed, get results
                    clearInterval(pollInterval);
                    await loadScanResults(scanId);
                    resetScanButton();
                } else if (status === 'failed') {
                    // Scan failed
                    clearInterval(pollInterval);
                    devicesList.innerHTML = `<div style="color: #F50000; padding: 20px;">‚ùå Tarama ba≈üarƒ±sƒ±z: ${data.error}</div>`;
                    resetScanButton();
                } else if (status === 'cancelled') {
                    // Scan cancelled
                    clearInterval(pollInterval);
                    devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">‚ö†Ô∏è Tarama iptal edildi</div>';
                    resetScanButton();
                } else {
                    // Still running - show incremental results
                    const devicesFound = data.devices_found || 0;

                    // Try to get partial results
                    try {
                        const resultsResponse = await fetch(`/api/scan/results/${scanId}`);
                        const resultsData = await resultsResponse.json();

                        if (resultsData.success && resultsData.devices && resultsData.devices.length > 0) {
                            // Display partial results
                            displayDevicesIncremental(resultsData.devices, true);
                        } else {
                            devicesList.innerHTML = `<div style="color: #CCD6F6; padding: 20px;">‚è≥ Tarama devam ediyor... (${devicesFound} cihaz bulundu)</div>`;
                        }
                    } catch (e) {
                        devicesList.innerHTML = `<div style="color: #CCD6F6; padding: 20px;">‚è≥ Tarama devam ediyor... (${devicesFound} cihaz bulundu)</div>`;
                    }
                }
            }
        } catch (error) {
            console.error('Status poll error:', error);
        }
    }, 500);  // Poll every 500ms for faster updates
}

// Load and display scan results
async function loadScanResults(scanId) {
    try {
        const response = await fetch(`/api/scan/results/${scanId}`);
        const data = await response.json();

        if (data.success && data.devices && data.devices.length > 0) {
            displayDevices(data.devices);
        } else {
            devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">‚ö†Ô∏è Tarama tamamlandƒ±, ancak cihaz bulunamadƒ±.</div>';
        }
    } catch (error) {
        console.error('Results load error:', error);
        devicesList.innerHTML = '<div style="color: #F50000; padding: 20px;">‚ùå Sonu√ßlar y√ºklenemedi</div>';
    }
}

// Display devices in the UI
function displayDevices(devices) {
    devicesList.innerHTML = '';

    devices.forEach((device, index) => {
        const deviceItem = document.createElement('div');
        deviceItem.className = 'device-item';
        if (index === 0) deviceItem.classList.add('device-selected');

        // Get device icon
        const iconInfo = getDeviceIcon(device.hostname || device.ip, device.os || '');

        // Count vulnerabilities (placeholder for now)
        const vulnCounts = device.vulnerabilities || { critical: 0, medium: 0, low: 0 };
        const portCount = device.ports ? device.ports.length : 0;

        deviceItem.innerHTML = `
            <div class="device-icon">
                <img src="${iconInfo.src}" alt="${iconInfo.alt}" class="device-icon-img" 
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
                <span class="device-icon-fallback" style="display:none;">${iconInfo.fallback}</span>
            </div>
            <div class="device-info">
                <div class="device-name">${device.ip} (${device.hostname})</div>
                <div class="device-stats">
                    ${vulnCounts.critical > 0 ? `<span class="stat-critical">üî• Kritik: ${vulnCounts.critical}</span>` : ''}
                    ${vulnCounts.medium > 0 ? `<span class="stat-medium">üü† Orta: ${vulnCounts.medium}</span>` : ''}
                    ${vulnCounts.low > 0 ? `<span class="stat-low">üü° D√º≈ü√ºk: ${vulnCounts.low}</span>` : ''}
                    ${portCount > 0 ? `<span class="stat-safe">üü¢ Port: ${portCount}</span>` : '<span class="stat-safe">üü¢ Aktif</span>'}
                </div>
            </div>
            <div class="device-arrow">></div>
        `;

        // Store device data
        deviceItem.dataset.deviceData = JSON.stringify(device);

        // Add click handler
        deviceItem.addEventListener('click', () => {
            document.querySelectorAll('.device-item').forEach(d => d.classList.remove('device-selected'));
            deviceItem.classList.add('device-selected');
            displayTechnicalDetails(device);
        });

        devicesList.appendChild(deviceItem);
    });

    // Display first device details
    if (devices.length > 0) {
        displayTechnicalDetails(devices[0]);
    }
}

// Display technical details for selected device
function displayTechnicalDetails(device) {
    const detailsHeader = document.querySelector('.details-header');
    const detailsTerminal = document.querySelector('.details-terminal');

    detailsHeader.textContent = `Teknik Detaylar: ${device.ip} (${device.hostname})`;

    if (device.ports && device.ports.length > 0) {
        let html = `
            <div style="margin-bottom: 20px; display: flex; justify-content: flex-end;">
                <button onclick='analyzeWithAI(${JSON.stringify(device)})' class="btn-ai-analyze" style="
                    background: linear-gradient(90deg, #7928CA, #FF0080);
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    color: white;
                    font-weight: 600;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-family: 'Inter', sans-serif;
                    box-shadow: 0 4px 12px rgba(121, 40, 202, 0.3);
                    transition: transform 0.2s;
                ">
                    ‚ú® AI ile Zafiyet Analizi
                </button>
            </div>
            <div id="ai-analysis-result" style="margin-bottom: 20px; display: none;"></div>
            <div class="terminal-row">
                <div class="terminal-label">PORT</div>
                <div class="terminal-label">STATE</div>
                <div class="terminal-label">SERVICE</div>
                <div class="terminal-label">VERSION</div>
            </div>
        `;

        device.ports.forEach(port => {
            html += `
                <div class="terminal-row">
                    <div class="terminal-value">${port.port}/${port.protocol}</div>
                    <div class="terminal-value" style="color: #38C271;">${port.state}</div>
                    <div class="terminal-value" style="color: #63B3ED;">${port.service || 'unknown'}</div>
                    <div class="terminal-value">${port.version || port.product || '-'}</div>
                </div>
            `;
        });

        detailsTerminal.innerHTML = html;
    } else {
        detailsTerminal.innerHTML = `
            <div style="margin-bottom: 20px; display: flex; justify-content: flex-end;">
                <button onclick='analyzeWithAI(${JSON.stringify(device)})' class="btn-ai-analyze" style="
                    background: linear-gradient(90deg, #7928CA, #FF0080);
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    color: white;
                    font-weight: 600;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-family: 'Inter', sans-serif;
                ">
                    ‚ú® AI ile Zafiyet Analizi
                </button>
            </div>
            <div id="ai-analysis-result" style="margin-bottom: 20px; display: none;"></div>
            <div class="terminal-row">
                <div class="terminal-label">PORT</div>
                <div class="terminal-label">STATE</div>
                <div class="terminal-label">SERVICE</div>
                <div class="terminal-label">VERSION</div>
            </div>
            <div style="color: #CCD6F6; padding: 20px;">A√ßƒ±k port bulunamadƒ± (Host Discovery modu)</div>
        `;
    }
}

// AI Analysis Function
async function analyzeWithAI(device) {
    const aiPanel = document.getElementById('aiAnalysisPanel');
    const btn = event.target;

    // Show loading
    btn.disabled = true;
    btn.innerHTML = '‚è≥ Analiz yapƒ±lƒ±yor...';
    btn.style.opacity = '0.8';

    // Show AI panel with loading state
    aiPanel.style.display = 'block';
    aiPanel.innerHTML = `
        <div class="ai-loading" style="text-align: center; padding: 40px; color: #CCD6F6;">
            <div style="font-size: 2em; margin-bottom: 10px;">ü§ñ</div>
            <div>Gemini AI cihazƒ± analiz ediyor...</div>
            <div style="font-size: 0.9em; color: #888D9D; margin-top: 10px;">Bu i≈ülem birka√ß saniye s√ºrebilir</div>
        </div>
    `;

    try {
        const response = await fetch('/api/analyze/device', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(device)
        });

        const data = await response.json();

        if (data.success) {
            const analysis = data.analysis;

            // Update toggle button title with hostname
            const displayName = device.hostname && device.hostname !== 'N/A' && device.hostname !== device.ip
                ? `${device.hostname} [${device.ip}]`
                : device.ip;
            document.getElementById('aiPanelTitle').textContent = `Yapay Zeka G√ºvenlik Analizi: ${displayName}`;

            // Store analysis data globally for selection
            window.currentAnalysis = analysis;
            window.currentDevice = device;

            // Build AI panel
            buildAIPanel(analysis, device);
        } else {
            aiPanel.innerHTML = `
                <div style="background: rgba(245, 0, 0, 0.1); border: 1px solid #F50000; border-radius: 8px; padding: 20px; text-align: center;">
                    <div style="color: #F50000; font-size: 1.2em;">‚ö†Ô∏è Analiz Hatasƒ±</div>
                    <div style="color: #CCD6F6; margin-top: 10px;">${data.error}</div>
                </div>
            `;
        }
    } catch (error) {
        console.error('AI Error:', error);
        aiPanel.innerHTML = `
            <div style="background: rgba(245, 0, 0, 0.1); border: 1px solid #F50000; border-radius: 8px; padding: 20px; text-align: center;">
                <div style="color: #F50000; font-size: 1.2em;">‚ö†Ô∏è Baƒülantƒ± Hatasƒ±</div>
                <div style="color: #CCD6F6; margin-top: 10px;">${error.message}</div>
            </div>
        `;
    } finally {
        btn.disabled = false;
        btn.innerHTML = '‚ú® AI ile Tekrar Analiz Et';
        btn.style.opacity = '1';
    }
}

function buildAIPanel(analysis, device) {
    const aiPanel = document.getElementById('aiAnalysisPanel');

    // Build vulnerability list items
    let vulnListHtml = `
        <button class="vuln-item vuln-general vuln-selected" onclick="selectVulnerability('general')">
            üõ°Ô∏è Genel √ñzet
        </button>
    `;

    if (analysis.vulnerabilities && analysis.vulnerabilities.length > 0) {
        analysis.vulnerabilities.forEach((vuln, index) => {
            const severityClass = getSeverityClass(vuln.severity);
            vulnListHtml += `
                <button class="vuln-item ${severityClass}" onclick="selectVulnerability(${index})">
                    ${vuln.title}
                </button>
            `;
        });
    }

    // Build panel HTML (no header, just content)
    aiPanel.innerHTML = `
        <div class="ai-content">
            <!-- Left: Vulnerability List -->
            <div class="vulnerability-list">
                <h3 class="vuln-list-title">Zafiyet Listesi</h3>
                <div class="vuln-items">
                    ${vulnListHtml}
                </div>
            </div>

            <!-- Right: CVE Details -->
            <div class="cve-details" id="cveDetailsPanel">
                <!-- Will be populated by selectVulnerability() -->
            </div>
        </div>
    `;

    // Select general overview by default
    selectVulnerability('general');
}

function selectVulnerability(index) {
    const analysis = window.currentAnalysis;
    const device = window.currentDevice;
    const detailsPanel = document.getElementById('cveDetailsPanel');

    // Update selected state in list
    document.querySelectorAll('.vuln-item').forEach(item => {
        item.classList.remove('vuln-selected');
    });

    if (index === 'general') {
        // Show general overview
        document.querySelector('.vuln-general').classList.add('vuln-selected');

        const riskColor = getRiskColor(analysis.risk_score);
        const riskLevel = analysis.risk_level || getRiskLevel(analysis.risk_score);

        detailsPanel.innerHTML = `
            <div class="cve-header">Genel G√ºvenlik √ñzeti</div>
            
            <div class="cve-cards">
                <!-- Risk Score Card -->
                <div class="cve-card cve-card-${riskLevel.toLowerCase()}">
                    <div class="cve-card-title">${riskLevel.toUpperCase()}</div>
                    <div class="cve-risk-label">Risk Puanƒ±</div>
                    <div class="cve-risk-score">${analysis.risk_score}/10</div>
                    <div class="cve-risk-type">Genel Deƒüerlendirme</div>
                </div>

                <!-- Summary Card -->
                <div class="cve-card cve-card-analysis">
                    <div class="cve-card-title-analysis">√ñzet Analiz</div>
                    <div class="cve-analysis-text">
                        ${analysis.summary}
                    </div>
                </div>

                <!-- Recommendations Card -->
                <div class="cve-card cve-card-recommendations">
                    <div class="cve-card-title-recommendations">√ñnerilen Adƒ±mlar</div>
                    <ul class="cve-recommendations-list">
                        ${analysis.recommendations && analysis.recommendations.length > 0
                ? analysis.recommendations.map(r => `<li>${r}</li>`).join('')
                : '<li>Tespit edilen zafiyetleri inceleyin ve gerekli g√ºncellemeleri yapƒ±n.</li>'}
                    </ul>
                </div>
            </div>
        `;
    } else {
        // Show specific vulnerability
        const vuln = analysis.vulnerabilities[index];
        document.querySelectorAll('.vuln-item')[index + 1].classList.add('vuln-selected');

        const severityClass = getSeverityClass(vuln.severity);
        const severityColor = getSeverityColor(vuln.severity);

        detailsPanel.innerHTML = `
            <div class="cve-header">${vuln.title}</div>
            
            <div class="cve-cards">
                <!-- Severity Card -->
                <div class="cve-card cve-card-${severityClass}">
                    <div class="cve-card-title">${vuln.severity.toUpperCase()}</div>
                    <div class="cve-risk-label">Risk Puanƒ±</div>
                    <div class="cve-risk-score">${vuln.cvss_score || 'N/A'}/10</div>
                    <div class="cve-risk-type">Port: ${vuln.affected_port || 'N/A'}</div>
                </div>

                <!-- Description Card -->
                <div class="cve-card cve-card-analysis">
                    <div class="cve-card-title-analysis">Risk Analizi</div>
                    <div class="cve-analysis-text">
                        ${vuln.description}
                    </div>
                </div>

                <!-- Recommendations Card -->
                <div class="cve-card cve-card-recommendations">
                    <div class="cve-card-title-recommendations">√ñnerilen Adƒ±mlar</div>
                    <ul class="cve-recommendations-list">
                        ${analysis.recommendations && analysis.recommendations.length > 0
                ? analysis.recommendations.slice(0, 3).map(r => `<li>${r}</li>`).join('')
                : '<li>ƒ∞lgili servisi g√ºncelleyin veya devre dƒ±≈üƒ± bƒ±rakƒ±n.</li>'}
                    </ul>
                </div>
            </div>
        `;
    }
}

// Helper functions
function getSeverityClass(severity) {
    const sev = severity.toLowerCase();
    if (sev === 'critical') return 'vuln-critical';
    if (sev === 'high') return 'vuln-high';
    if (sev === 'medium') return 'vuln-medium';
    return 'vuln-low';
}

function getSeverityColor(severity) {
    const sev = severity.toLowerCase();
    if (sev === 'critical') return '#F50000';
    if (sev === 'high') return '#F59E0B';
    if (sev === 'medium') return '#FFE100';
    return '#38C271';
}

function getRiskColor(score) {
    if (score >= 9.0) return '#F50000';
    if (score >= 7.0) return '#F59E0B';
    if (score >= 4.0) return '#FFE100';
    return '#38C271';
}

function getRiskLevel(score) {
    if (score >= 9.0) return 'Critical';
    if (score >= 7.0) return 'High';
    if (score >= 4.0) return 'Medium';
    return 'Low';
}

// Auto Fill Button
const autoFillBtn = document.querySelector('.btn-auto-fill');
if (autoFillBtn) {
    autoFillBtn.addEventListener('click', () => {
        // Auto-fill with local network range (placeholder)
        const inputField = document.querySelector('.input-field');
        if (inputField) {
            inputField.value = '10.0.2.0/24';
            console.log('Auto-filled target range');
        }
    });
}

// Search Input
const searchInput = document.querySelector('.search-input');
if (searchInput) {
    searchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();

        document.querySelectorAll('.device-item').forEach(device => {
            const deviceName = device.querySelector('.device-name').textContent.toLowerCase();
            if (deviceName.includes(searchTerm)) {
                device.style.display = 'flex';
            } else {
                device.style.display = 'none';
            }
        });
    });
}

// ===== TAB SWITCHING LOGIC =====
const tabBtns = document.querySelectorAll('.tab-btn');
const tabContents = document.querySelectorAll('.tab-content');

tabBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        const targetTab = btn.dataset.tab;

        // Remove active class from all tabs and contents
        tabBtns.forEach(b => b.classList.remove('active'));
        tabContents.forEach(content => content.classList.remove('active'));

        // Add active class to clicked tab and corresponding content
        btn.classList.add('active');
        const targetContent = document.getElementById(`${targetTab}-content`);
        if (targetContent) {
            targetContent.classList.add('active');
        }
    });
});

// ===== WEB SCAN LOGIC =====

// Gobuster checkbox toggle
const gobusterCheckbox = document.getElementById('gobuster-enabled');
const gobusterOptions = document.getElementById('gobuster-options');
const gobusterThreads = document.getElementById('gobuster-threads');
const gobusterDelay = document.getElementById('gobuster-delay');

if (gobusterCheckbox) {
    gobusterCheckbox.addEventListener('change', () => {
        if (gobusterCheckbox.checked) {
            gobusterOptions.style.display = 'block';
            gobusterThreads.disabled = false;
            gobusterDelay.disabled = false;
        } else {
            gobusterOptions.style.display = 'none';
            gobusterThreads.disabled = true;
            gobusterDelay.disabled = true;
        }
    });
}

// Nikto checkbox toggle
const niktoCheckbox = document.getElementById('nikto-enabled');
const niktoOptions = document.getElementById('nikto-options');
const niktoScanType = document.getElementById('nikto-scan-type');
const niktoDelay = document.getElementById('nikto-delay');

if (niktoCheckbox) {
    niktoCheckbox.addEventListener('change', () => {
        if (niktoCheckbox.checked) {
            niktoOptions.style.display = 'block';
            niktoScanType.disabled = false;
            niktoDelay.disabled = false;
        } else {
            niktoOptions.style.display = 'none';
            niktoScanType.disabled = true;
            niktoDelay.disabled = true;
        }
    });
}

// Wordlist upload checkbox toggle
const wordlistUploadCheckbox = document.getElementById('wordlist-upload-enabled');
const wordlistUploadBtn = document.getElementById('wordlist-upload-btn');
const wordlistFileInput = document.getElementById('wordlist-file-input');

if (wordlistUploadCheckbox) {
    wordlistUploadCheckbox.addEventListener('change', () => {
        if (wordlistUploadCheckbox.checked) {
            wordlistUploadBtn.disabled = false;
        } else {
            wordlistUploadBtn.disabled = true;
        }
    });
}

// Wordlist file upload button
if (wordlistUploadBtn) {
    wordlistUploadBtn.addEventListener('click', () => {
        wordlistFileInput.click();
    });
}

// Handle wordlist file selection
if (wordlistFileInput) {
    wordlistFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const wordlistManual = document.getElementById('wordlist-manual');
                if (wordlistManual) {
                    wordlistManual.value = event.target.result;
                }
            };
            reader.readAsText(file);
        }
    });
}

// Web Scan Start Button
const webScanStartBtn = document.getElementById('web-scan-start');
let currentWebScanId = null;
let webScanPollInterval = null;
let isWebScanning = false;

if (webScanStartBtn) {
    webScanStartBtn.addEventListener('click', async () => {
        // If scanning, cancel the scan
        if (isWebScanning) {
            await cancelWebScan();
            return;
        }

        // Collect scan parameters
        const targetUrl = document.getElementById('web-target-url').value;

        if (!targetUrl) {
            alert('L√ºtfen hedef URL girin (√∂rn: https://example.com)');
            return;
        }

        const gobusterEnabled = document.getElementById('gobuster-enabled').checked;
        const niktoEnabled = document.getElementById('nikto-enabled').checked;

        if (!gobusterEnabled && !niktoEnabled) {
            alert('L√ºtfen en az bir tarama t√ºr√º se√ßin (Gobuster veya Nikto)');
            return;
        }

        const webScanParams = {
            target_url: targetUrl,
            gobuster: {
                enabled: gobusterEnabled,
                threads: gobusterEnabled ? (document.getElementById('gobuster-threads').value || '10') : null,
                delay: gobusterEnabled ? (document.getElementById('gobuster-delay').value || '0') : null
            },
            nikto: {
                enabled: niktoEnabled,
                scan_type: niktoEnabled ? document.getElementById('nikto-scan-type').value : null,
                delay: niktoEnabled ? (document.getElementById('nikto-delay').value || '0') : null
            },
            ssl_enforce: document.getElementById('ssl-enforce').checked,
            wordlist: document.getElementById('wordlist-manual').value
        };

        console.log('Starting web scan with parameters:', webScanParams);

        try {
            // Change button to cancel mode
            isWebScanning = true;
            webScanStartBtn.classList.add('scanning');
            webScanStartBtn.textContent = 'ƒ∞ptal Et';

            // Clear previous results
            const webTableBody = document.getElementById('web-table-body');
            webTableBody.innerHTML = '<div style="color: #CCD6F6; padding: 20px; text-align: center;">Tarama ba≈ülatƒ±lƒ±yor...</div>';

            // Clear Nikto terminal
            const niktoTerminal = document.getElementById('nikto-terminal');
            niktoTerminal.innerHTML = '<div style="color: #888D9D; font-style: italic;">Tarama ba≈ülatƒ±lƒ±yor...</div>';

            // Start scan via API
            const response = await fetch('/api/webscan/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(webScanParams)
            });

            const data = await response.json();

            if (data.success) {
                currentWebScanId = data.scan_id;
                // Start polling for results
                pollWebScanStatus(currentWebScanId);
            } else {
                throw new Error(data.error || 'Web taramasƒ± ba≈ülatƒ±lamadƒ±');
            }
        } catch (error) {
            console.error('Web scan error:', error);
            alert(`Hata: ${error.message}`);
            resetWebScanButton();
        }
    });
}

// Poll web scan status
function pollWebScanStatus(scanId) {
    webScanPollInterval = setInterval(async () => {
        try {
            const response = await fetch(`/api/webscan/status/${scanId}`);
            const data = await response.json();

            if (!data.success) {
                clearInterval(webScanPollInterval);
                alert(`Tarama hatasƒ±: ${data.error}`);
                resetWebScanButton();
                return;
            }

            // Update Gobuster results
            if (data.gobuster && data.gobuster.enabled) {
                updateGobusterResults(data.gobuster.results);
            }

            // Update Nikto output
            if (data.nikto && data.nikto.enabled) {
                updateNiktoOutput(data.nikto.output);
            }

            // Check if scan is completed
            if (data.status === 'completed' || data.status === 'error' || data.status === 'cancelled') {
                clearInterval(webScanPollInterval);
                resetWebScanButton();

                if (data.status === 'error') {
                    alert('Tarama sƒ±rasƒ±nda hata olu≈ütu');
                }
            }

        } catch (error) {
            console.error('Polling error:', error);
            clearInterval(webScanPollInterval);
            resetWebScanButton();
        }
    }, 1000); // Poll every second
}

// Update Gobuster results in table
function updateGobusterResults(results) {
    const webTableBody = document.getElementById('web-table-body');

    if (!results || results.length === 0) {
        webTableBody.innerHTML = '<div style="color: #888D9D; padding: 20px; text-align: center;">Hen√ºz sonu√ß bulunamadƒ±...</div>';
        return;
    }

    webTableBody.innerHTML = '';

    results.forEach(result => {
        const row = document.createElement('div');
        row.className = 'table-row';

        row.innerHTML = `
            <div class="table-cell path">${result.path}</div>
            <div class="table-cell status status-${result.status}">${result.status}</div>
            <div class="table-cell">${result.size}</div>
            <div class="table-cell">${result.type}</div>
        `;

        webTableBody.appendChild(row);
    });
}

// Update Nikto output in terminal
function updateNiktoOutput(outputLines) {
    const niktoTerminal = document.getElementById('nikto-terminal');

    if (!outputLines || outputLines.length === 0) {
        niktoTerminal.innerHTML = '<div style="color: #888D9D; font-style: italic;">Tarama devam ediyor...</div>';
        return;
    }

    niktoTerminal.innerHTML = '';

    outputLines.forEach(line => {
        const lineDiv = document.createElement('div');
        lineDiv.className = `nikto-line nikto-${line.type}`;
        lineDiv.textContent = line.message;
        niktoTerminal.appendChild(lineDiv);
    });

    // Auto-scroll to bottom
    niktoTerminal.scrollTop = niktoTerminal.scrollHeight;
}

// Cancel web scan function
async function cancelWebScan() {
    if (!currentWebScanId) {
        resetWebScanButton();
        return;
    }

    try {
        const response = await fetch(`/api/webscan/cancel/${currentWebScanId}`, {
            method: 'POST'
        });

        const data = await response.json();

        if (data.success) {
            const webTableBody = document.getElementById('web-table-body');
            webTableBody.innerHTML = '<div style="color: #FFE100; padding: 20px; text-align: center;">‚ö†Ô∏è Tarama iptal edildi</div>';
        } else {
            alert(`ƒ∞ptal hatasƒ±: ${data.error}`);
        }
    } catch (error) {
        console.error('Cancel error:', error);
        alert(`ƒ∞ptal hatasƒ±: ${error.message}`);
    } finally {
        resetWebScanButton();
        if (webScanPollInterval) {
            clearInterval(webScanPollInterval);
        }
    }
}

// Reset web scan button to initial state
function resetWebScanButton() {
    isWebScanning = false;
    webScanStartBtn.classList.remove('scanning');
    webScanStartBtn.textContent = 'Taramayƒ± Ba≈ülat';
    webScanStartBtn.disabled = false;
}

// Web scan filter buttons
const webFilterBtns = document.querySelectorAll('#web-scan-content .filter-btn');
webFilterBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        // Remove active class from all filters
        webFilterBtns.forEach(b => b.classList.remove('filter-active'));
        // Add active class to clicked filter
        btn.classList.add('filter-active');

        const filter = btn.dataset.filter;
        console.log('Web filter clicked:', filter);

        // TODO: Implement filtering logic
        // Filter table rows based on status code
    });
});

// Web scan search input
const webSearchInput = document.getElementById('web-search-input');
if (webSearchInput) {
    webSearchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();

        document.querySelectorAll('.table-row').forEach(row => {
            const pathCell = row.querySelector('.table-cell.path');
            if (pathCell) {
                const path = pathCell.textContent.toLowerCase();
                if (path.includes(searchTerm)) {
                    row.style.display = 'grid';
                } else {
                    row.style.display = 'none';
                }
            }
        });
    });
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    console.log('Pentest Otomasyon Motoru initialized');
    updatePortSelectionState(); // Ensure correct initial state
});
