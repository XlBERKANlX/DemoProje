// Wait for DOM to be fully loaded before initializing
document.addEventListener('DOMContentLoaded', function () {
    console.log('DOM loaded, initializing app...');

    // Radio Button Logic - Host Discovery vs Port Selection
    const scanTypeRadios = document.querySelectorAll('input[name="scan-type"]');
    const portSelectionRadios = document.querySelectorAll('input[name="port-selection"]');

    // Add toggle functionality to radio buttons (click again to deselect)
    function makeRadioToggleable(radioButtons) {
        radioButtons.forEach(radio => {
            radio.addEventListener('click', function (e) {
                // If already checked, uncheck it
                if (this.dataset.wasChecked === 'true') {
                    this.checked = false;
                    this.dataset.wasChecked = 'false';
                    // Trigger change event to update dependent states
                    this.dispatchEvent(new Event('change'));
                } else {
                    // Mark all radios in this group as unchecked
                    radioButtons.forEach(r => r.dataset.wasChecked = 'false');
                    // Mark this one as checked
                    this.dataset.wasChecked = 'true';
                }
            });
        });
    }

    // Apply toggle functionality to both radio groups
    makeRadioToggleable(scanTypeRadios);
    makeRadioToggleable(portSelectionRadios);

    function updatePortSelectionState() {
        const hostDiscoveryRadio = document.querySelector('input[name="scan-type"][value="host"]');
        const hostDiscoverySelected = hostDiscoveryRadio?.checked;

        portSelectionRadios.forEach(radio => {
            if (hostDiscoverySelected) {
                // Disable port selection when Host Discovery is selected
                radio.disabled = true;
                radio.checked = false;
                radio.dataset.wasChecked = 'false';
                radio.parentElement.style.opacity = '0.5';
                radio.parentElement.style.cursor = 'not-allowed';
            } else {
                // Enable port selection for other scan types
                radio.disabled = false;
                radio.parentElement.style.opacity = '1';
                radio.parentElement.style.cursor = 'pointer';
            }
        });
    }

    // When port selection is made, auto-deselect host discovery
    portSelectionRadios.forEach(radio => {
        radio.addEventListener('change', () => {
            if (radio.checked) {
                const hostDiscoveryRadio = document.querySelector('input[name="scan-type"][value="host"]');
                if (hostDiscoveryRadio && hostDiscoveryRadio.checked) {
                    hostDiscoveryRadio.checked = false;
                    hostDiscoveryRadio.dataset.wasChecked = 'false';
                    updatePortSelectionState();
                }
            }
        });
    });

    // Listen to scan type changes
    scanTypeRadios.forEach(radio => {
        radio.addEventListener('change', updatePortSelectionState);
    });

    // Initialize on page load - port options enabled by default
    updatePortSelectionState();

    // AI Analysis Panel Toggle
    const aiToggleBtn = document.getElementById('aiToggleBtn');
    const aiAnalysisPanel = document.getElementById('aiAnalysisPanel');

    aiToggleBtn.addEventListener('click', () => {
        aiAnalysisPanel.classList.toggle('open');
        aiToggleBtn.classList.toggle('active');
    });

    // Device Selection
    const deviceItems = document.querySelectorAll('.device-item');
    deviceItems.forEach(device => {
        device.addEventListener('click', () => {
            // Remove selected class from all devices
            deviceItems.forEach(d => d.classList.remove('device-selected'));
            // Add selected class to clicked device
            device.classList.add('device-selected');

            // Update technical details (placeholder - will be dynamic with backend)
            const deviceName = device.querySelector('.device-name').textContent;
            document.querySelector('.details-header').textContent = `Teknik Detaylar: ${deviceName}`;
        });
    });

    // Vulnerability Item Selection
    const vulnItems = document.querySelectorAll('.vuln-item');
    const cveSeverityCard = document.getElementById('cveSeverityCard');

    vulnItems.forEach(item => {
        item.addEventListener('click', () => {
            // Remove selected class from all items
            vulnItems.forEach(v => v.classList.remove('vuln-selected'));
            // Add selected class to clicked item
            item.classList.add('vuln-selected');

            // Update CVE details (placeholder - will be dynamic with backend)
            const vulnText = item.textContent.trim();
            document.querySelector('.cve-header').textContent = vulnText;

            // Update CVE severity card color based on vulnerability type
            if (cveSeverityCard) {
                // Remove all severity classes
                cveSeverityCard.classList.remove('cve-card-critical', 'cve-card-medium', 'cve-card-low');

                // Add appropriate class based on selected vulnerability
                if (item.classList.contains('vuln-critical')) {
                    cveSeverityCard.classList.add('cve-card-critical');
                } else if (item.classList.contains('vuln-medium')) {
                    cveSeverityCard.classList.add('cve-card-medium');
                } else if (item.classList.contains('vuln-low')) {
                    cveSeverityCard.classList.add('cve-card-low');
                } else {
                    // Default to critical for general overview
                    cveSeverityCard.classList.add('cve-card-critical');
                }
            }
        });
    });

    // Filter Buttons
    const filterBtns = document.querySelectorAll('.filter-btn');
    filterBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // Remove active class from all filters
            filterBtns.forEach(b => b.classList.remove('filter-active'));
            // Add active class to clicked filter
            btn.classList.add('filter-active');

            // Filter logic will be implemented with backend data
            console.log('Filter clicked:', btn.textContent);
        });
    });

    // Start Scan Button - BACKEND INTEGRATION
    const startScanBtn = document.querySelector('.btn-start-scan');
    const devicesList = document.querySelector('.devices-list');
    let currentScanId = null;
    let pollInterval = null;
    let isScanning = false;

    startScanBtn.addEventListener('click', async () => {
        // If scanning, cancel the scan
        if (isScanning) {
            await cancelScan();
            return;
        }

        // Collect scan parameters
        const targets = document.querySelector('.input-field').value;

        if (!targets) {
            alert('Lütfen tarama hedefi girin (örn: 10.0.2.5 veya 10.0.2.0/24)');
            return;
        }

        const scanParams = {
            targets: targets,
            scanType: document.querySelector('input[name="scan-type"]:checked')?.value || 'host',
            portSelection: document.querySelector('input[name="port-selection"]:checked')?.value,
            synScan: document.querySelector('input[name="syn-scan"]')?.checked || false,
            versionScan: document.querySelector('input[name="version-scan"]')?.checked || false,
            osScan: document.querySelector('input[name="os-scan"]')?.checked || false,
            speed: document.querySelector('.select-field')?.value || 'normal'
        };

        console.log('Starting scan with parameters:', scanParams);

        try {
            // Change button to cancel mode
            isScanning = true;
            startScanBtn.classList.add('scanning');
            startScanBtn.textContent = 'İptal Et';

            // Clear previous results
            devicesList.innerHTML = '<div style="color: #CCD6F6; padding: 20px;">Tarama başlatılıyor...</div>';

            // Start scan
            const response = await fetch('/api/scan/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(scanParams)
            });

            const data = await response.json();

            if (data.success) {
                currentScanId = data.scan_id;
                devicesList.innerHTML = '<div style="color: #CCD6F6; padding: 20px;">⏳ Tarama devam ediyor...</div>';

                // Start polling for results
                pollScanStatus(currentScanId);
            } else {
                throw new Error(data.error || 'Tarama başlatılamadı');
            }
        } catch (error) {
            console.error('Scan error:', error);
            alert(`Hata: ${error.message}`);
            resetScanButton();
            devicesList.innerHTML = '<div style="color: #F50000; padding: 20px;">❌ Tarama başlatılamadı: ' + error.message + '</div>';
        }
    });

    // Cancel scan function
    async function cancelScan() {
        if (!currentScanId) return;

        try {
            const response = await fetch(`/api/scan/cancel/${currentScanId}`, {
                method: 'POST'
            });

            const data = await response.json();

            if (data.success) {
                devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">⚠️ Tarama iptal edildi</div>';
            } else {
                alert(`İptal hatası: ${data.error}`);
            }
        } catch (error) {
            console.error('Cancel error:', error);
            alert(`İptal hatası: ${error.message}`);
        } finally {
            resetScanButton();
            if (pollInterval) {
                clearInterval(pollInterval);
            }
        }
    }

    // Reset scan button to initial state
    function resetScanButton() {
        isScanning = false;
        startScanBtn.classList.remove('scanning');
        startScanBtn.textContent = 'Taramayı Başlat';
        startScanBtn.disabled = false;
    }

    // Poll scan status and results
    function pollScanStatus(scanId) {
        // Clear any existing interval
        if (pollInterval) {
            clearInterval(pollInterval);
        }

        // Poll every 2 seconds
        pollInterval = setInterval(async () => {
            try {
                const response = await fetch(`/api/scan/status/${scanId}`);
                const data = await response.json();

                if (data.success) {
                    const status = data.status;

                    if (status === 'completed') {
                        // Scan completed, get results
                        clearInterval(pollInterval);
                        await loadScanResults(scanId);
                        resetScanButton();
                    } else if (status === 'failed') {
                        // Scan failed
                        clearInterval(pollInterval);
                        devicesList.innerHTML = `<div style="color: #F50000; padding: 20px;">❌ Tarama başarısız: ${data.error}</div>`;
                        resetScanButton();
                    } else if (status === 'cancelled') {
                        // Scan cancelled
                        clearInterval(pollInterval);
                        devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">⚠️ Tarama iptal edildi</div>';
                        resetScanButton();
                    } else {
                        // Still running - show incremental results
                        const devicesFound = data.devices_found || 0;

                        // Try to get partial results
                        try {
                            const resultsResponse = await fetch(`/api/scan/results/${scanId}`);
                            const resultsData = await resultsResponse.json();

                            if (resultsData.success && resultsData.devices && resultsData.devices.length > 0) {
                                // Display partial results
                                displayDevicesIncremental(resultsData.devices, true);
                            } else {
                                devicesList.innerHTML = `<div style="color: #CCD6F6; padding: 20px;">⏳ Tarama devam ediyor... (${devicesFound} cihaz bulundu)</div>`;
                            }
                        } catch (e) {
                            devicesList.innerHTML = `<div style="color: #CCD6F6; padding: 20px;">⏳ Tarama devam ediyor... (${devicesFound} cihaz bulundu)</div>`;
                        }
                    }
                }
            } catch (error) {
                console.error('Status poll error:', error);
            }
        }, 500);  // Poll every 500ms for faster updates
    }

    // Load and display scan results
    async function loadScanResults(scanId) {
        try {
            const response = await fetch(`/api/scan/results/${scanId}`);
            const data = await response.json();

            if (data.success && data.devices && data.devices.length > 0) {
                displayDevices(data.devices);
            } else {
                devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">⚠️ Tarama tamamlandı, ancak cihaz bulunamadı.</div>';
            }
        } catch (error) {
            console.error('Results load error:', error);
            devicesList.innerHTML = '<div style="color: #F50000; padding: 20px;">❌ Sonuçlar yüklenemedi</div>';
        }
    }

    // Display devices in the UI
    function displayDevices(devices) {
        devicesList.innerHTML = '';

        devices.forEach((device, index) => {
            const deviceItem = document.createElement('div');
            deviceItem.className = 'device-item';
            if (index === 0) deviceItem.classList.add('device-selected');

            // Get device icon
            const iconInfo = getDeviceIcon(device.hostname || device.ip, device.os || '');

            // Count vulnerabilities (placeholder for now)
            const vulnCounts = device.vulnerabilities || { critical: 0, medium: 0, low: 0 };
            const portCount = device.ports ? device.ports.length : 0;

            deviceItem.innerHTML = `
            <div class="device-icon">
                <img src="${iconInfo.src}" alt="${iconInfo.alt}" class="device-icon-img" 
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
                <span class="device-icon-fallback" style="display:none;">${iconInfo.fallback}</span>
            </div>
            <div class="device-info">
                <div class="device-name">${device.ip} (${device.hostname})</div>
                <div class="device-stats">
                    ${vulnCounts.critical > 0 ? `<span class="stat-critical">🔥 Kritik: ${vulnCounts.critical}</span>` : ''}
                    ${vulnCounts.medium > 0 ? `<span class="stat-medium">🟠 Orta: ${vulnCounts.medium}</span>` : ''}
                    ${vulnCounts.low > 0 ? `<span class="stat-low">🟡 Düşük: ${vulnCounts.low}</span>` : ''}
                    ${portCount > 0 ? `<span class="stat-safe">🟢 Port: ${portCount}</span>` : '<span class="stat-safe">🟢 Aktif</span>'}
                </div>
            </div>
            <div class="device-arrow">></div>
        `;

            // Store device data
            deviceItem.dataset.deviceData = JSON.stringify(device);

            // Add click handler
            deviceItem.addEventListener('click', () => {
                document.querySelectorAll('.device-item').forEach(d => d.classList.remove('device-selected'));
                deviceItem.classList.add('device-selected');
                displayTechnicalDetails(device);
            });

            devicesList.appendChild(deviceItem);
        });

        // Display first device details
        if (devices.length > 0) {
            displayTechnicalDetails(devices[0]);
        }
    }

    // Display technical details for selected device
    function displayTechnicalDetails(device) {
        const detailsHeader = document.querySelector('.details-header');
        const detailsTerminal = document.querySelector('.details-terminal');

        detailsHeader.textContent = `Teknik Detaylar: ${device.ip} (${device.hostname})`;

        if (device.ports && device.ports.length > 0) {
            let html = `
            <div style="margin-bottom: 20px; display: flex; justify-content: flex-end;">
                <button onclick='analyzeWithAI(${JSON.stringify(device)})' class="btn-ai-analyze" style="
                    background: linear-gradient(90deg, #7928CA, #FF0080);
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    color: white;
                    font-weight: 600;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-family: 'Inter', sans-serif;
                    box-shadow: 0 4px 12px rgba(121, 40, 202, 0.3);
                    transition: transform 0.2s;
                ">
                    ✨ AI ile Zafiyet Analizi
                </button>
            </div>
            <div id="ai-analysis-result" style="margin-bottom: 20px; display: none;"></div>
            <div class="terminal-row">
                <div class="terminal-label">PORT</div>
                <div class="terminal-label">STATE</div>
                <div class="terminal-label">SERVICE</div>
                <div class="terminal-label">VERSION</div>
            </div>
        `;

            device.ports.forEach(port => {
                html += `
                <div class="terminal-row">
                    <div class="terminal-value">${port.port}/${port.protocol}</div>
                    <div class="terminal-value" style="color: #38C271;">${port.state}</div>
                    <div class="terminal-value" style="color: #63B3ED;">${port.service || 'unknown'}</div>
                    <div class="terminal-value">${port.version || port.product || '-'}</div>
                </div>
            `;
            });

            detailsTerminal.innerHTML = html;
        } else {
            detailsTerminal.innerHTML = `
            <div style="margin-bottom: 20px; display: flex; justify-content: flex-end;">
                <button onclick='analyzeWithAI(${JSON.stringify(device)})' class="btn-ai-analyze" style="
                    background: linear-gradient(90deg, #7928CA, #FF0080);
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    color: white;
                    font-weight: 600;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-family: 'Inter', sans-serif;
                ">
                    ✨ AI ile Zafiyet Analizi
                </button>
            </div>
            <div id="ai-analysis-result" style="margin-bottom: 20px; display: none;"></div>
            <div class="terminal-row">
                <div class="terminal-label">PORT</div>
                <div class="terminal-label">STATE</div>
                <div class="terminal-label">SERVICE</div>
                <div class="terminal-label">VERSION</div>
            </div>
            <div style="color: #CCD6F6; padding: 20px;">Açık port bulunamadı (Host Discovery modu)</div>
        `;
        }
    }

    // AI Analysis Function
    async function analyzeWithAI(device) {
        const aiPanel = document.getElementById('aiAnalysisPanel');
        const btn = event.target;

        // Show loading
        btn.disabled = true;
        btn.innerHTML = '⏳ Analiz yapılıyor...';
        btn.style.opacity = '0.8';

        // Show AI panel with loading state
        aiPanel.style.display = 'block';
        aiPanel.innerHTML = `
        <div class="ai-loading" style="text-align: center; padding: 40px; color: #CCD6F6;">
            <div style="font-size: 2em; margin-bottom: 10px;">🤖</div>
            <div>Gemini AI cihazı analiz ediyor...</div>
            <div style="font-size: 0.9em; color: #888D9D; margin-top: 10px;">Bu işlem birkaç saniye sürebilir</div>
        </div>
    `;

        try {
            const response = await fetch('/api/analyze/device', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(device)
            });

            const data = await response.json();

            if (data.success) {
                const analysis = data.analysis;

                // Update toggle button title with hostname
                const displayName = device.hostname && device.hostname !== 'N/A' && device.hostname !== device.ip
                    ? `${device.hostname} [${device.ip}]`
                    : device.ip;
                document.getElementById('aiPanelTitle').textContent = `Yapay Zeka Güvenlik Analizi: ${displayName}`;

                // Store analysis data globally for selection
                window.currentAnalysis = analysis;
                window.currentDevice = device;

                // Build AI panel
                buildAIPanel(analysis, device);
            } else {
                aiPanel.innerHTML = `
                <div style="background: rgba(245, 0, 0, 0.1); border: 1px solid #F50000; border-radius: 8px; padding: 20px; text-align: center;">
                    <div style="color: #F50000; font-size: 1.2em;">⚠️ Analiz Hatası</div>
                    <div style="color: #CCD6F6; margin-top: 10px;">${data.error}</div>
                </div>
            `;
            }
        } catch (error) {
            console.error('AI Error:', error);
            aiPanel.innerHTML = `
            <div style="background: rgba(245, 0, 0, 0.1); border: 1px solid #F50000; border-radius: 8px; padding: 20px; text-align: center;">
                <div style="color: #F50000; font-size: 1.2em;">⚠️ Bağlantı Hatası</div>
                <div style="color: #CCD6F6; margin-top: 10px;">${error.message}</div>
            </div>
        `;
        } finally {
            btn.disabled = false;
            btn.innerHTML = '✨ AI ile Tekrar Analiz Et';
            btn.style.opacity = '1';
        }
    }

    function buildAIPanel(analysis, device) {
        const aiPanel = document.getElementById('aiAnalysisPanel');

        // Build vulnerability list items
        let vulnListHtml = `
        <button class="vuln-item vuln-general vuln-selected" onclick="selectVulnerability('general')">
            🛡️ Genel Özet
        </button>
    `;

        if (analysis.vulnerabilities && analysis.vulnerabilities.length > 0) {
            analysis.vulnerabilities.forEach((vuln, index) => {
                const severityClass = getSeverityClass(vuln.severity);
                vulnListHtml += `
                <button class="vuln-item ${severityClass}" onclick="selectVulnerability(${index})">
                    ${vuln.title}
                </button>
            `;
            });
        }

        // Build panel HTML (no header, just content)
        aiPanel.innerHTML = `
        <div class="ai-content">
            <!-- Left: Vulnerability List -->
            <div class="vulnerability-list">
                <h3 class="vuln-list-title">Zafiyet Listesi</h3>
                <div class="vuln-items">
                    ${vulnListHtml}
                </div>
            </div>

            <!-- Right: CVE Details -->
            <div class="cve-details" id="cveDetailsPanel">
                <!-- Will be populated by selectVulnerability() -->
            </div>
        </div>
    `;

        // Select general overview by default
        selectVulnerability('general');
    }

    window.selectVulnerability = function (index) {
        const analysis = window.currentAnalysis;
        const device = window.currentDevice;
        const detailsPanel = document.getElementById('cveDetailsPanel');

        // Update selected state in list
        document.querySelectorAll('.vuln-item').forEach(item => {
            item.classList.remove('vuln-selected');
        });

        if (index === 'general') {
            // Show general overview
            document.querySelector('.vuln-general').classList.add('vuln-selected');

            const riskColor = getRiskColor(analysis.risk_score);
            const riskLevel = analysis.risk_level || getRiskLevel(analysis.risk_score);

            detailsPanel.innerHTML = `
            <div class="cve-header">Genel Güvenlik Özeti</div>
            
            <div class="cve-cards">
                <!-- Risk Score Card -->
                <div class="cve-card cve-card-${riskLevel.toLowerCase()}">
                    <div class="cve-card-title">${riskLevel.toUpperCase()}</div>
                    <div class="cve-risk-label">Risk Puanı</div>
                    <div class="cve-risk-score">${analysis.risk_score}/10</div>
                    <div class="cve-risk-type">Genel Değerlendirme</div>
                </div>

                <!-- Summary Card -->
                <div class="cve-card cve-card-analysis">
                    <div class="cve-card-title-analysis">Özet Analiz</div>
                    <div class="cve-analysis-text">
                        ${analysis.summary}
                    </div>
                </div>

                <!-- Recommendations Card -->
                <div class="cve-card cve-card-recommendations">
                    <div class="cve-card-title-recommendations">Önerilen Adımlar</div>
                    <ul class="cve-recommendations-list">
                        ${analysis.recommendations && analysis.recommendations.length > 0
                    ? analysis.recommendations.map(r => `<li>${r}</li>`).join('')
                    : '<li>Tespit edilen zafiyetleri inceleyin ve gerekli güncellemeleri yapın.</li>'}
                    </ul>
                </div>
            </div>
        `;
        } else {
            // Show specific vulnerability
            const vuln = analysis.vulnerabilities[index];
            document.querySelectorAll('.vuln-item')[index + 1].classList.add('vuln-selected');

            const severityClass = getSeverityClass(vuln.severity);
            const severityColor = getSeverityColor(vuln.severity);

            detailsPanel.innerHTML = `
            <div class="cve-header">${vuln.title}</div>
            
            <div class="cve-cards">
                <!-- Severity Card -->
                <div class="cve-card cve-card-${severityClass}">
                    <div class="cve-card-title">${vuln.severity.toUpperCase()}</div>
                    <div class="cve-risk-label">Risk Puanı</div>
                    <div class="cve-risk-score">${vuln.cvss_score || 'N/A'}/10</div>
                    <div class="cve-risk-type">Port: ${vuln.affected_port || 'N/A'}</div>
                </div>

                <!-- Description Card -->
                <div class="cve-card cve-card-analysis">
                    <div class="cve-card-title-analysis">Risk Analizi</div>
                    <div class="cve-analysis-text">
                        ${vuln.description}
                    </div>
                </div>

                <!-- Recommendations Card -->
                <div class="cve-card cve-card-recommendations">
                    <div class="cve-card-title-recommendations">Önerilen Adımlar</div>
                    <ul class="cve-recommendations-list">
                        ${analysis.recommendations && analysis.recommendations.length > 0
                    ? analysis.recommendations.slice(0, 3).map(r => `<li>${r}</li>`).join('')
                    : '<li>İlgili servisi güncelleyin veya devre dışı bırakın.</li>'}
                    </ul>
                </div>
            </div>
        `;
        }
    }

    // Helper functions
    function getSeverityClass(severity) {
        const sev = severity.toLowerCase();
        if (sev === 'critical') return 'vuln-critical';
        if (sev === 'high') return 'vuln-high';
        if (sev === 'medium') return 'vuln-medium';
        return 'vuln-low';
    }

    function getSeverityColor(severity) {
        const sev = severity.toLowerCase();
        if (sev === 'critical') return '#F50000';
        if (sev === 'high') return '#F59E0B';
        if (sev === 'medium') return '#FFE100';
        return '#38C271';
    }

    function getRiskColor(score) {
        if (score >= 9.0) return '#F50000';
        if (score >= 7.0) return '#F59E0B';
        if (score >= 4.0) return '#FFE100';
        return '#38C271';
    }

    function getRiskLevel(score) {
        if (score >= 9.0) return 'Critical';
        if (score >= 7.0) return 'High';
        if (score >= 4.0) return 'Medium';
        return 'Low';
    }

    // Auto Fill Button
    const autoFillBtn = document.querySelector('.btn-auto-fill');
    if (autoFillBtn) {
        autoFillBtn.addEventListener('click', () => {
            // Auto-fill with local network range (placeholder)
            const inputField = document.querySelector('.input-field');
            if (inputField) {
                inputField.value = '10.0.2.0/24';
                console.log('Auto-filled target range');
            }
        });
    }

    // Search Input
    const searchInput = document.querySelector('.search-input');
    if (searchInput) {
        searchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();

            document.querySelectorAll('.device-item').forEach(device => {
                const deviceName = device.querySelector('.device-name').textContent.toLowerCase();
                if (deviceName.includes(searchTerm)) {
                    device.style.display = 'flex';
                } else {
                    device.style.display = 'none';
                }
            });
        });
    }


    // ===== TAB SWITCHING LOGIC =====
    // (Tab switching handlers are at the end of the file)


    // ===== WEB SCAN LOGIC =====
    // (Conditional input handlers are at the end of the file)

    // Web scan start button

    // Wordlist file upload button
    const wordlistUploadBtn = document.getElementById('wordlist-upload-btn');
    const wordlistFileInput = document.getElementById('wordlist-file-input');
    const wordlistUploadCheckbox = document.getElementById('wordlist-upload-enabled');

    // Toggle upload button based on checkbox
    if (wordlistUploadCheckbox && wordlistUploadBtn) {
        wordlistUploadCheckbox.addEventListener('change', function () {
            wordlistUploadBtn.disabled = !this.checked;
        });
    }

    if (wordlistUploadBtn) {
        wordlistUploadBtn.addEventListener('click', () => {
            wordlistFileInput.click();
        });
    }

    // Handle wordlist file selection
    if (wordlistFileInput) {
        wordlistFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const wordlistManual = document.getElementById('wordlist-manual');
                    if (wordlistManual) {
                        wordlistManual.value = event.target.result;
                        alert(`Wordlist yüklendi: ${file.name} (${file.size} bytes)`);
                    }
                };
                reader.onerror = (error) => {
                    console.error('File read error:', error);
                    alert('Dosya okuma hatası!');
                };
                reader.readAsText(file);
            }
        });
    }

    // Web Scan Start Button
    const webScanStartBtn = document.getElementById('web-scan-start');
    let currentWebScanId = null;
    let webScanPollInterval = null;
    let isWebScanning = false;

    if (webScanStartBtn) {
        webScanStartBtn.addEventListener('click', async () => {
            // If scanning, cancel the scan
            if (isWebScanning) {
                await cancelWebScan();
                return;
            }

            // Collect scan parameters
            const targetUrl = document.getElementById('web-target-url').value;

            if (!targetUrl) {
                alert('Lütfen hedef URL girin (örn: https://example.com)');
                return;
            }

            const gobusterEnabled = document.getElementById('gobuster-enabled').checked;
            const niktoEnabled = document.getElementById('nikto-enabled').checked;

            if (!gobusterEnabled && !niktoEnabled) {
                alert('Lütfen en az bir tarama türü seçin (Gobuster veya Nikto)');
                return;
            }

            const webScanParams = {
                target_url: targetUrl,
                gobuster: {
                    enabled: gobusterEnabled,
                    threads: gobusterEnabled ? (document.getElementById('gobuster-threads').value || '10') : null,
                    delay: gobusterEnabled ? (document.getElementById('gobuster-delay').value || '0') : null
                },
                nikto: {
                    enabled: niktoEnabled,
                    scan_type: niktoEnabled ? document.getElementById('nikto-scan-type').value : null,
                    delay: niktoEnabled ? (document.getElementById('nikto-delay').value || '0') : null,
                    recursive: niktoEnabled ? document.getElementById('nikto-recursive').checked : false
                },
                ssl_enforce: document.getElementById('ssl-enforce').checked,
                recursive: niktoEnabled ? document.getElementById('nikto-recursive').checked : false,
                recursive_mode: niktoEnabled && document.getElementById('nikto-recursive').checked ?
                    (document.querySelector('input[name="recursive-mode"]:checked')?.value || 'base') : 'base',
                wordlist: document.getElementById('wordlist-manual').value
            };

            console.log('Starting web scan with parameters:', webScanParams);

            try {
                // Change button to cancel mode
                isWebScanning = true;
                webScanStartBtn.classList.add('scanning');
                webScanStartBtn.textContent = 'İptal Et';

                // Clear previous results
                const webTableBody = document.getElementById('web-table-body');
                webTableBody.innerHTML = '<div style="color: #CCD6F6; padding: 20px; text-align: center;">Tarama başlatılıyor...</div>';

                // Clear Nikto terminal
                const niktoTerminal = document.getElementById('nikto-terminal');
                niktoTerminal.innerHTML = '<div style="color: #888D9D; font-style: italic;">Tarama başlatılıyor...</div>';

                // Start scan via API
                const response = await fetch('/api/webscan/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(webScanParams)
                });

                const data = await response.json();

                if (data.success) {
                    currentWebScanId = data.scan_id;
                    // Start polling for results
                    pollWebScanStatus(currentWebScanId);
                } else {
                    throw new Error(data.error || 'Web taraması başlatılamadı');
                }
            } catch (error) {
                console.error('Web scan error:', error);
                alert(`Hata: ${error.message}`);
                resetWebScanButton();
            }
        });
    }

    // Poll web scan status
    function pollWebScanStatus(scanId) {
        webScanPollInterval = setInterval(async () => {
            try {
                const response = await fetch(`/api/webscan/status/${scanId}`);
                const data = await response.json();

                if (!data.success) {
                    clearInterval(webScanPollInterval);
                    alert(`Tarama hatası: ${data.error}`);
                    resetWebScanButton();
                    return;
                }

                // Update Gobuster results
                if (data.gobuster && data.gobuster.enabled) {
                    updateGobusterResults(data.gobuster.results);
                }

                // Update Nikto output
                if (data.nikto && data.nikto.enabled) {
                    updateNiktoOutput(data.nikto.output);
                }

                // Check if scan is completed
                if (data.status === 'completed' || data.status === 'error' || data.status === 'cancelled') {
                    clearInterval(webScanPollInterval);
                    resetWebScanButton();

                    if (data.status === 'error') {
                        alert('Tarama sırasında hata oluştu');
                    }
                }

            } catch (error) {
                console.error('Polling error:', error);
                clearInterval(webScanPollInterval);
                resetWebScanButton();
            }
        }, 1000); // Poll every second
    }

    // Update Gobuster results in table
    function updateGobusterResults(results) {
        const webTableBody = document.getElementById('web-table-body');

        if (!results || results.length === 0) {
            webTableBody.innerHTML = '<div style="color: #888D9D; padding: 20px; text-align: center;">Henüz sonuç bulunamadı...</div>';
            return;
        }

        webTableBody.innerHTML = '';

        results.forEach(result => {
            const row = document.createElement('div');
            row.className = 'table-row';

            row.innerHTML = `
            <div class="table-cell path">${result.path}</div>
            <div class="table-cell status status-${result.status}">${result.status}</div>
            <div class="table-cell">${result.size}</div>
            <div class="table-cell">${result.type}</div>
        `;

            webTableBody.appendChild(row);
        });
    }

    // Update Nikto output in terminal
    function updateNiktoOutput(outputLines) {
        const niktoTerminal = document.getElementById('nikto-terminal');

        if (!outputLines || outputLines.length === 0) {
            niktoTerminal.innerHTML = '<div style="color: #888D9D; font-style: italic;">Tarama devam ediyor...</div>';
            return;
        }

        niktoTerminal.innerHTML = '';

        outputLines.forEach(line => {
            const lineDiv = document.createElement('div');
            lineDiv.className = `nikto-line nikto-${line.type}`;
            lineDiv.textContent = line.message;
            niktoTerminal.appendChild(lineDiv);
        });

        // Auto-scroll to bottom
        niktoTerminal.scrollTop = niktoTerminal.scrollHeight;
    }

    // Cancel web scan function
    async function cancelWebScan() {
        if (!currentWebScanId) {
            resetWebScanButton();
            return;
        }

        try {
            const response = await fetch(`/api/webscan/cancel/${currentWebScanId}`, {
                method: 'POST'
            });

            const data = await response.json();

            if (data.success) {
                const webTableBody = document.getElementById('web-table-body');
                webTableBody.innerHTML = '<div style="color: #FFE100; padding: 20px; text-align: center;">⚠️ Tarama iptal edildi</div>';
            } else {
                alert(`İptal hatası: ${data.error}`);
            }
        } catch (error) {
            console.error('Cancel error:', error);
            alert(`İptal hatası: ${error.message}`);
        } finally {
            resetWebScanButton();
            if (webScanPollInterval) {
                clearInterval(webScanPollInterval);
            }
        }
    }

    // Reset web scan button to initial state
    function resetWebScanButton() {
        isWebScanning = false;
        webScanStartBtn.classList.remove('scanning');
        webScanStartBtn.textContent = 'Taramayı Başlat';
        webScanStartBtn.disabled = false;
    }

    // Web scan filter buttons
    const webFilterBtns = document.querySelectorAll('#web-scan-content .filter-btn');
    webFilterBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // Remove active class from all filters
            webFilterBtns.forEach(b => b.classList.remove('filter-active'));
            // Add active class to clicked filter
            btn.classList.add('filter-active');

            const filter = btn.dataset.filter;
            console.log('Web filter clicked:', filter);

            // TODO: Implement filtering logic
            // Filter table rows based on status code
        });
    });

    // Web scan search input
    const webSearchInput = document.getElementById('web-search-input');
    if (webSearchInput) {
        webSearchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();

            document.querySelectorAll('.table-row').forEach(row => {
                const pathCell = row.querySelector('.table-cell.path');
                if (pathCell) {
                    const path = pathCell.textContent.toLowerCase();
                    if (path.includes(searchTerm)) {
                        row.style.display = 'grid';
                    } else {
                        row.style.display = 'none';
                    }
                }
            });
        });
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        console.log('Pentest Otomasyon Motoru initialized');
        updatePortSelectionState(); // Ensure correct initial state
    });

    // ===== WEB SCAN AI ANALYSIS TOGGLE =====
    const webAiToggleBtn = document.getElementById('webAiToggleBtn');
    const webAiAnalysisPanel = document.getElementById('webAiAnalysisPanel');

    if (webAiToggleBtn && webAiAnalysisPanel) {
        webAiToggleBtn.addEventListener('click', function () {
            // Toggle active class on button
            webAiToggleBtn.classList.toggle('active');

            // Toggle open class on panel
            webAiAnalysisPanel.classList.toggle('open');
        });
    }

    // ===== WEB SCAN AI PATH-BASED ANALYSIS =====
    function initWebAiPathAnalysis() {
        // Path Selection Handler
        const pathButtons = document.querySelectorAll('.path-btn');
        pathButtons.forEach(btn => {
            btn.addEventListener('click', function () {
                // Remove selected class from all paths
                pathButtons.forEach(b => b.classList.remove('path-selected'));

                // Add selected class to clicked path
                this.classList.add('path-selected');

                // Get path data
                const pathData = this.dataset.path;

                // Update content based on selected path
                if (pathData === 'master') {
                    displayMasterPathAnalysis();
                } else {
                    displayPathAnalysis(pathData);
                }
            });
        });

        // Vulnerability Row Selection Handler
        const vulnTable = document.getElementById('webVulnsTableBody');
        if (vulnTable) {
            vulnTable.addEventListener('click', function (e) {
                const row = e.target.closest('.vuln-row');
                if (!row) return;

                // Remove selected class from all rows
                document.querySelectorAll('.vuln-row').forEach(r => {
                    r.classList.remove('vuln-row-selected');
                });

                // Add selected class to clicked row
                row.classList.add('vuln-row-selected');

                // Get vulnerability data
                const vulnId = row.dataset.vuln;
                displayVulnerabilityDetails(vulnId);
            });
        }

        // Path Search Handler
        const pathSearch = document.getElementById('webPathSearch');
        if (pathSearch) {
            pathSearch.addEventListener('input', function () {
                const searchTerm = this.value.toLowerCase();
                const dynamicPaths = document.querySelectorAll('#webDynamicPaths .path-btn');

                dynamicPaths.forEach(btn => {
                    const pathText = btn.querySelector('.path-text').textContent.toLowerCase();
                    if (pathText.includes(searchTerm)) {
                        btn.style.display = 'flex';
                    } else {
                        btn.style.display = 'none';
                    }
                });
            });
        }
    }

    function displayMasterPathAnalysis() {
        // Hide vulnerability table column
        const vulnsColumn = document.querySelector('.web-ai-vulns');
        if (vulnsColumn) {
            vulnsColumn.style.display = 'none';
        }

        // Adjust grid to make attack path larger and centered
        const grid = document.querySelector('.web-ai-grid');
        if (grid) {
            grid.style.gridTemplateColumns = '250px 2fr 2fr';
        }

        // Update attack path header with gradient
        const attackHeader = document.querySelector('.web-ai-attack-header');
        if (attackHeader) {
            attackHeader.innerHTML = '<span style="background: linear-gradient(90deg, #00E6FF 20%, #8008CF 83%); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">MASTER PATH</span>';
        }

        // Update attack path content
        const attackBody = document.getElementById('webAttackBody');
        if (attackBody) {
            attackBody.innerHTML = `
            <div style="margin-bottom: 16px; font-weight: 600; text-align: center;">SaldÄ±rÄ± Yolu</div>
            <p style="margin-bottom: 12px; text-align: center;">Sistem genelinde yapÄ±lan detaylÄ± taramalar ile birlikte saldÄ±rganÄ±n sisteme sÄ±zabileceÄŸi en kritik ve etkili saldÄ±rÄ± yolu:</p>
            <ol class="attack-steps">
                <li>1)................</li>
                <li>2)................</li>
                <li>3)................</li>
                <li>4)................</li>
            </ol>
        `;
        }

        // Update recommendations
        const recBody = document.getElementById('webRecommendationsBody');
        if (recBody) {
            recBody.innerHTML = `
            <div style="margin-bottom: 16px; font-weight: 600; text-align: center;">Sistem Genelindeki aÃ§Ä±klar iÃ§in Ã–nerilen DÃ¼zeltme AdÄ±mlarÄ±</div>
            <ol class="recommendation-steps">
                <li>1)...........</li>
                <li>2)...........</li>
            </ol>
        `;
        }
    }

    function displayPathAnalysis(pathName) {
        // Show vulnerability table column
        const vulnsColumn = document.querySelector('.web-ai-vulns');
        if (vulnsColumn) {
            vulnsColumn.style.display = 'block';
        }

        // Reset grid to normal
        const grid = document.querySelector('.web-ai-grid');
        if (grid) {
            grid.style.gridTemplateColumns = '250px 1.5fr 1fr 1fr';
        }

        // Update header with path name
        const header = document.getElementById('webVulnsHeader');
        if (header) {
            header.textContent = `${pathName} Path (OrtRisk)`;
        }

        // Update attack path for specific path
        const attackBody = document.getElementById('webAttackBody');
        if (attackBody) {
            attackBody.innerHTML = `
            <ol class="attack-steps">
                <li>X aÃ§Ä±ÄŸÄ±nÄ± sÃ¶mÃ¼rmek iÃ§in</li>
                <li>...</li>
                <li>...</li>
                <li>...</li>
            </ol>
        `;
        }

        // Update recommendations for specific path
        const recBody = document.getElementById('webRecommendationsBody');
        if (recBody) {
            recBody.innerHTML = `
            <ol class="recommendation-steps">
                <li>1)...........</li>
                <li>2)...........</li>
            </ol>
        `;
        }
    }

    function displayVulnerabilityDetails(vulnId) {
        // Update attack path based on selected vulnerability
        const attackBody = document.getElementById('webAttackBody');
        if (attackBody) {
            attackBody.innerHTML = `
            <ol class="attack-steps">
                <li>SeÃ§ili aÃ§Ä±ÄŸÄ± sÃ¶mÃ¼rmek iÃ§in adÄ±m 1</li>
                <li>AdÄ±m 2...</li>
                <li>AdÄ±m 3...</li>
                <li>AdÄ±m 4...</li>
            </ol>
        `;
        }

        // Update recommendations based on selected vulnerability
        const recBody = document.getElementById('webRecommendationsBody');
        if (recBody) {
            recBody.innerHTML = `
            <ol class="recommendation-steps">
                <li>Bu aÃ§Ä±ÄŸÄ± kapatmak iÃ§in Ã¶neri 1</li>
                <li>Ã–neri 2...</li>
            </ol>
        `;
        }
    }

    // Initialize on page load
    // Initialize Web AI Path Analysis
    initWebAiPathAnalysis();

    // ===== TAB SWITCHING =====
    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');

    tabButtons.forEach(btn => {
        btn.addEventListener('click', function () {
            const targetTab = this.dataset.tab;

            // Remove active class from all tabs and buttons
            tabButtons.forEach(b => b.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));

            // Add active class to clicked button
            this.classList.add('active');

            // Show corresponding tab content
            const targetContent = document.getElementById(targetTab + '-content');
            if (targetContent) {
                targetContent.classList.add('active');
            }
        });
    });

    // ===== WEB SCAN CONDITIONAL INPUTS =====
    // Gobuster checkbox handler
    const gobusterCheckbox = document.getElementById('gobuster-enabled');
    const gobusterOptions = document.getElementById('gobuster-options');
    const gobusterThreads = document.getElementById('gobuster-threads');
    const gobusterDelay = document.getElementById('gobuster-delay');

    console.log('Gobuster elements:', {
        checkbox: !!gobusterCheckbox,
        options: !!gobusterOptions,
        threads: !!gobusterThreads,
        delay: !!gobusterDelay
    });

    if (gobusterCheckbox) {
        console.log('Attaching gobuster change listener...');
        gobusterCheckbox.addEventListener('change', function () {
            console.log('Gobuster checkbox changed:', this.checked);
            if (this.checked) {
                gobusterOptions.style.display = 'block';
                gobusterThreads.disabled = false;
                gobusterDelay.disabled = false;
            } else {
                gobusterOptions.style.display = 'none';
                gobusterThreads.disabled = true;
                gobusterDelay.disabled = true;
            }
        });
    } else {
        console.error('gobuster-enabled checkbox NOT FOUND!');
    }

    // Nikto checkbox handler
    const niktoCheckbox = document.getElementById('nikto-enabled');
    const niktoOptions = document.getElementById('nikto-options');
    const niktoScanType = document.getElementById('nikto-scan-type');
    const niktoDelay = document.getElementById('nikto-delay');
    const niktoRecursive = document.getElementById('nikto-recursive');

    if (niktoCheckbox) {
        niktoCheckbox.addEventListener('change', function () {
            if (this.checked) {
                niktoOptions.style.display = 'block';
                niktoScanType.disabled = false;
                niktoDelay.disabled = false;
                if (niktoRecursive) niktoRecursive.disabled = false;
            } else {
                niktoOptions.style.display = 'none';
                niktoScanType.disabled = true;
                niktoDelay.disabled = true;
                if (niktoRecursive) {
                    niktoRecursive.disabled = true;
                    niktoRecursive.checked = false;
                }
            }
        });
    }



    // Wordlist radio buttons handler
    const wordlistRadios = document.querySelectorAll('input[name="wordlist-type"]');
    const wordlistInput = document.getElementById('wordlistInput');
    const wordlistUpload = document.getElementById('wordlistUpload');

    wordlistRadios.forEach(radio => {
        radio.addEventListener('change', function () {
            if (this.value === 'input') {
                if (wordlistInput) wordlistInput.style.display = 'block';
                if (wordlistUpload) wordlistUpload.style.display = 'none';
            } else {
                if (wordlistInput) wordlistInput.style.display = 'none';
                if (wordlistUpload) wordlistUpload.style.display = 'block';
            }
        });
    });

    // Helper function to update AI UI with analysis results
    function updateAiAnalysisUI(data) {
        if (!data || !data.ai_analysis) {
            console.error("Invalid AI analysis data");
            return;
        }

        const analysis = data.ai_analysis;

        // Create a virtual "device" for the network summary
        const virtualDevice = {
            ip: 'Tüm Ağ',
            hostname: 'Tarama Özeti',
            os: 'Mixed',
            ports: [],
            vulnerabilities: {} // Populated dynamically by buildAIPanel if needed
        };

        // Update global state
        window.currentAnalysis = analysis;
        window.currentDevice = virtualDevice;

        // Update title
        const titleEl = document.getElementById('aiPanelTitle');
        if (titleEl) {
            titleEl.textContent = "Yapay Zeka Güvenlik Analizi: Ağ Özeti";
        }

        // Reuse existing panel builder
        buildAIPanel(analysis, virtualDevice);
    }

    function startAiAnalysis() {
        const aiPanel = document.getElementById('aiAnalysisPanel');
        const aiToggleBtn = document.getElementById('aiToggleBtn');

        if (!currentScanId) {
            alert("Lütfen önce bir ağ taraması yapın!");
            return;
        }

        // Show loading state
        if (aiToggleBtn) {
            const span = aiToggleBtn.querySelector('span');
            if (span) span.innerHTML = "⏳ Analiz Yapılıyor...";
            aiToggleBtn.disabled = true;
        }

        fetch(`http://localhost:5000/api/scan/analyze/${currentScanId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({}),
        })
            .then(response => response.json())
            .then(data => {
                console.log('AI Analysis:', data);
                if (data.error) {
                    alert('Hata: ' + data.error);
                } else {
                    // Populate UI
                    updateAiAnalysisUI(data);
                    // Open Panel
                    if (aiPanel && !aiPanel.classList.contains('open')) {
                        if (aiToggleBtn) aiToggleBtn.click();
                    }
                    // Success Notification
                    alert("✅ AI Analizi Başarıyla Tamamlandı!");
                }
            })
            .catch((error) => {
                console.error('Error:', error);
                alert('Analiz sırasında bir hata oluştu.');
            })
            .finally(() => {
                if (aiToggleBtn) {
                    const span = aiToggleBtn.querySelector('span');
                    if (span) span.innerText = "Yapay Zeka Güvenlik Analizi";
                    aiToggleBtn.disabled = false;
                }
            });
    }

    // Recursive Scan Checkbox Logic
    // niktoRecursive is already defined above
    const recursiveOptions = document.getElementById('recursive-mode-options');

    if (niktoRecursive && recursiveOptions) {
        niktoRecursive.addEventListener('change', function () {
            if (this.checked) {
                recursiveOptions.style.display = 'block';
            } else {
                recursiveOptions.style.display = 'none';
            }
        });
    }

    // Web Scan AI Analysis
    const webStartAiBtn = document.getElementById('webStartAiBtn');

    if (webStartAiBtn) {
        webStartAiBtn.addEventListener('click', startWebAiAnalysis);
    }

    function startWebAiAnalysis() {
        const aiToggleBtn = document.getElementById('webAiToggleBtn');
        const aiPanel = document.getElementById('webAiAnalysisPanel');

        // Check for currentWebScanId (need to ensure this variable is tracking web scan IDs)
        // If not global, we might need to find where it's set. 
        // Assuming currentWebScanId is defined/accessible or we need to capture it.
        // For now, let's assume currentWebScanId is global/available scope like currentScanId.
        if (typeof currentWebScanId === 'undefined' || !currentWebScanId) {
            alert("Lütfen önce bir Web taraması yapın!");
            return;
        }

        // Show loading
        if (aiToggleBtn) {
            aiToggleBtn.innerHTML = "<span>⏳</span> Analiz Yapılıyor...";
            aiToggleBtn.disabled = true;
        }

        fetch(`http://localhost:5000/api/scan/analyze/${currentWebScanId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    displayWebAiAnalysis(data.ai_analysis);
                    if (aiPanel) aiPanel.style.display = 'block';
                    alert("✅ Web AI Analizi Tamamlandı!");
                } else {
                    alert("Hata: " + data.error);
                }
            })
            .catch(err => {
                console.error(err);
                alert("Analiz sırasında hata oluştu.");
            })
            .finally(() => {
                if (aiToggleBtn) {
                    aiToggleBtn.innerHTML = "<span>✨</span> Yapay Zeka Güvenlik Analizi";
                    aiToggleBtn.disabled = false;
                }
            });
    }

    function displayWebAiAnalysis(aiData) {
        console.log("Displaying Web AI Data:", aiData);

        // 1. Setup Path Navigation (Left Column)
        const pathsContainer = document.querySelector('.web-ai-paths');
        // Helper to find or create search container
        let searchContainer = pathsContainer.querySelector('.web-ai-search');
        if (!searchContainer) {
            searchContainer = document.createElement('div');
            searchContainer.className = 'web-ai-search';
            searchContainer.innerHTML = `<input type="text" id="webPathSearch" class="path-search-input" placeholder="Path Ara...">`;
            // Insert after header if possible
            const header = pathsContainer.querySelector('.web-ai-paths-header');
            if (header && header.nextSibling) pathsContainer.insertBefore(searchContainer, header.nextSibling);
            else pathsContainer.appendChild(searchContainer);
        }

        // Clear existing buttons (except header/search if we want to keep them, but easier to rebuild lists)
        const existingButtons = pathsContainer.querySelectorAll('.path-btn');
        existingButtons.forEach(btn => btn.remove());

        let dynamicContainer = document.getElementById('webDynamicPaths');
        if (!dynamicContainer) {
            dynamicContainer = document.createElement('div');
            dynamicContainer.id = 'webDynamicPaths';
            pathsContainer.appendChild(dynamicContainer);
        } else {
            dynamicContainer.innerHTML = '';
        }

        // Create MASTER PATH Button
        const masterBtn = document.createElement('button');
        masterBtn.className = 'path-btn path-master-btn path-selected';
        masterBtn.dataset.path = 'master';
        masterBtn.innerHTML = '<span class="path-master-text">MASTER PATH</span>';
        masterBtn.onclick = () => renderView('master');

        // Create General Button
        const generalBtn = document.createElement('button');
        generalBtn.className = 'path-btn path-general-btn';
        generalBtn.dataset.path = 'general';
        generalBtn.innerHTML = `
            <span class="path-text">General/server-wide</span>
            <span class="path-risk">(${aiData.general?.avg_risk || 'N/A'})</span>
        `;
        generalBtn.onclick = () => renderView('general');

        // Append Fixed Buttons before dynamic container
        pathsContainer.insertBefore(masterBtn, dynamicContainer);
        pathsContainer.insertBefore(generalBtn, dynamicContainer);

        // Generate Dynamic Path Buttons
        if (aiData.paths) {
            Object.keys(aiData.paths).forEach(path => {
                const pData = aiData.paths[path];
                const btn = document.createElement('button');

                // Determine color class based on risk
                let riskClass = 'path-low-btn';
                const risk = parseFloat(pData.avg_risk) || 0;
                if (risk >= 9) riskClass = 'path-critical-btn';
                else if (risk >= 7) riskClass = 'path-high-btn';
                else if (risk >= 4) riskClass = 'path-medium-btn';

                const statusCode = pData.status ? `<span class="status-badge s-${pData.status}">${pData.status}</span>` : '';

                btn.className = `path-btn ${riskClass}`;
                btn.dataset.path = path;
                btn.innerHTML = `
                    <div style="display:flex; justify-content:space-between; align-items:center; width:100%;">
                        <span class="path-text" style="overflow:hidden; text-overflow:ellipsis;">${path}</span>
                        <div style="display:flex; align-items:center; gap:5px;">
                            ${statusCode}
                            <span class="path-risk">(${pData.avg_risk})</span>
                        </div>
                    </div>
                `;
                btn.onclick = () => renderView('path', path);
                dynamicContainer.appendChild(btn);
            });
        }

        // --- View Renderer Function ---
        function renderView(type, key = null) {
            // Update Active State
            document.querySelectorAll('.path-btn').forEach(b => b.classList.remove('path-selected'));
            if (type === 'master') masterBtn.classList.add('path-selected');
            else if (type === 'general') generalBtn.classList.add('path-selected');
            else {
                // Find button by text content or dataset if simpler
                const allBtns = Array.from(pathsContainer.querySelectorAll('.path-btn'));
                const targetBtn = allBtns.find(b => b.dataset.path === key);
                if (targetBtn) targetBtn.classList.add('path-selected');
            }

            // Update Header
            const vulnsHeader = document.getElementById('webVulnsHeader');
            if (vulnsHeader) vulnsHeader.innerText = type === 'master' ? "MASTER SALDIRI SENARYOSU" :
                type === 'general' ? "Genel Sunucu Zafiyetleri" :
                    `${key} Analizi`;

            // Elements to Populate
            const vulnsBody = document.getElementById('webVulnsTableBody');
            const attackBody = document.getElementById('webAttackBody');
            const recBody = document.getElementById('webRecommendationsBody');

            // 1. POPULATE VULNERABILITIES (Middle Column)
            let vulnsHtml = '';

            if (type === 'master') {
                vulnsHtml = `<tr><td colspan="2" style="padding:15px;color:#ccc;text-align:center;">Özet Senaryo Görüntüleniyor</td></tr>`;
            }
            else if (type === 'general') {
                const vList = aiData.general?.vulnerabilities || [];
                if (vList.length === 0) vulnsHtml = '<tr><td colspan="2" style="text-align:center;">Kayıt bulunamadı</td></tr>';
                else {
                    vulnsHtml = vList.map(v => `
                        <tr class="vuln-row">
                            <td>${v.name || 'Zafiyet'}</td>
                            <td><span style="font-weight:bold; color:${getRiskColor(v.risk || v.cvss)}">${v.risk || v.cvss || '-'}</span></td>
                        </tr>
                    `).join('');
                }
            }
            else if (type === 'path' && key) {
                const vList = aiData.paths[key]?.vulnerabilities || [];
                if (vList.length === 0) vulnsHtml = '<tr><td colspan="2" style="text-align:center;">Kayıt bulunamadı</td></tr>';
                else {
                    vulnsHtml = vList.map(v => `
                        <tr class="vuln-row">
                            <td>${v.name || 'Zafiyet'}</td>
                            <td><span style="font-weight:bold; color:${getRiskColor(v.risk)}">${v.risk}</span></td>
                        </tr>
                    `).join('');
                }
            }

            if (vulnsBody) vulnsBody.innerHTML = vulnsHtml;

            // 2. POPULATE ATTACK PATH (Right Top)
            let steps = [];
            if (type === 'master') steps = aiData.master_steps || [];
            else if (type === 'general') steps = [aiData.general?.summary || "Genel sunucu analizi."];
            else if (type === 'path' && key) steps = aiData.paths[key]?.path_attack_scenario || [];

            if (attackBody) {
                attackBody.innerHTML = `<ol class="attack-steps">${steps.length > 0 ? steps.map(s => `<li>${s}</li>`).join('') : '<li>Veri yok</li>'
                    }</ol>`;
            }

            // 3. POPULATE RECOMMENDATIONS (Right Bottom)
            let recs = [];
            if (type === 'master') recs = aiData.master_recommendations || [];
            else if (type === 'general') recs = aiData.general?.recommendations || [];
            else if (type === 'path' && key) recs = aiData.paths[key]?.path_recommendations || [];

            if (recBody) {
                recBody.innerHTML = `<ol class="recommendation-steps">${recs.length > 0 ? recs.map(r => `<li>${r}</li>`).join('') : '<li>Veri yok</li>'
                    }</ol>`;
            }
        }

        // Helper for Risk Color (reuse existing if possible or define internal)
        function getRiskColor(val) {
            const s = parseFloat(val) || 0;
            if (s >= 9) return '#F50000'; // Critical
            if (s >= 7) return '#F59E0B'; // High
            if (s >= 4) return '#FFE100'; // Medium
            return '#38C271'; // Low
        }

        // Initialize Default View (Master)
        renderView('master');
    }


    // Expose analyzeWithAI globally
    window.analyzeWithAI = function (device) {
        console.log("Starting Analysis for device:", device);
        startAiAnalysis(device);
    };

}); // End DOMContentLoaded
