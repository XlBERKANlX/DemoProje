// Radio Button Logic - Host Discovery vs Port Selection
const scanTypeRadios = document.querySelectorAll('input[name="scan-type"]');
const portSelectionRadios = document.querySelectorAll('input[name="port-selection"]');

// Add toggle functionality to radio buttons (click again to deselect)
function makeRadioToggleable(radioButtons) {
    radioButtons.forEach(radio => {
        radio.addEventListener('click', function (e) {
            // If already checked, uncheck it
            if (this.dataset.wasChecked === 'true') {
                this.checked = false;
                this.dataset.wasChecked = 'false';
                // Trigger change event to update dependent states
                this.dispatchEvent(new Event('change'));
            } else {
                // Mark all radios in this group as unchecked
                radioButtons.forEach(r => r.dataset.wasChecked = 'false');
                // Mark this one as checked
                this.dataset.wasChecked = 'true';
            }
        });
    });
}

// Apply toggle functionality to both radio groups
makeRadioToggleable(scanTypeRadios);
makeRadioToggleable(portSelectionRadios);

function updatePortSelectionState() {
    const hostDiscoverySelected = document.querySelector('input[name="scan-type"][value="host"]').checked;

    portSelectionRadios.forEach(radio => {
        if (hostDiscoverySelected) {
            // Disable port selection when Host Discovery is selected
            radio.disabled = true;
            radio.checked = false;
            radio.parentElement.style.opacity = '0.5';
            radio.parentElement.style.cursor = 'not-allowed';
        } else {
            // Enable port selection for other scan types
            radio.disabled = false;
            radio.parentElement.style.opacity = '1';
            radio.parentElement.style.cursor = 'pointer';
        }
    });
}

// Listen to scan type changes
scanTypeRadios.forEach(radio => {
    radio.addEventListener('change', updatePortSelectionState);
});

// Initialize on page load
updatePortSelectionState();

// AI Analysis Panel Toggle
const aiToggleBtn = document.getElementById('aiToggleBtn');
const aiAnalysisPanel = document.getElementById('aiAnalysisPanel');

aiToggleBtn.addEventListener('click', () => {
    aiAnalysisPanel.classList.toggle('open');
    aiToggleBtn.classList.toggle('active');
});

// Device Selection
const deviceItems = document.querySelectorAll('.device-item');
deviceItems.forEach(device => {
    device.addEventListener('click', () => {
        // Remove selected class from all devices
        deviceItems.forEach(d => d.classList.remove('device-selected'));
        // Add selected class to clicked device
        device.classList.add('device-selected');

        // Update technical details (placeholder - will be dynamic with backend)
        const deviceName = device.querySelector('.device-name').textContent;
        document.querySelector('.details-header').textContent = `Teknik Detaylar: ${deviceName}`;
    });
});

// Vulnerability Item Selection
const vulnItems = document.querySelectorAll('.vuln-item');
const cveSeverityCard = document.getElementById('cveSeverityCard');

vulnItems.forEach(item => {
    item.addEventListener('click', () => {
        // Remove selected class from all items
        vulnItems.forEach(v => v.classList.remove('vuln-selected'));
        // Add selected class to clicked item
        item.classList.add('vuln-selected');

        // Update CVE details (placeholder - will be dynamic with backend)
        const vulnText = item.textContent.trim();
        document.querySelector('.cve-header').textContent = vulnText;

        // Update CVE severity card color based on vulnerability type
        if (cveSeverityCard) {
            // Remove all severity classes
            cveSeverityCard.classList.remove('cve-card-critical', 'cve-card-medium', 'cve-card-low');

            // Add appropriate class based on selected vulnerability
            if (item.classList.contains('vuln-critical')) {
                cveSeverityCard.classList.add('cve-card-critical');
            } else if (item.classList.contains('vuln-medium')) {
                cveSeverityCard.classList.add('cve-card-medium');
            } else if (item.classList.contains('vuln-low')) {
                cveSeverityCard.classList.add('cve-card-low');
            } else {
                // Default to critical for general overview
                cveSeverityCard.classList.add('cve-card-critical');
            }
        }
    });
});

// Filter Buttons
const filterBtns = document.querySelectorAll('.filter-btn');
filterBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        // Remove active class from all filters
        filterBtns.forEach(b => b.classList.remove('filter-active'));
        // Add active class to clicked filter
        btn.classList.add('filter-active');

        // Filter logic will be implemented with backend data
        console.log('Filter clicked:', btn.textContent);
    });
});

// Start Scan Button
const startScanBtn = document.querySelector('.btn-start-scan');
startScanBtn.addEventListener('click', () => {
    // Collect scan parameters
    const scanParams = {
        targets: document.querySelector('.input-field').value,
        scanType: document.querySelector('input[name="scan-type"]:checked')?.value,
        portSelection: document.querySelector('input[name="port-selection"]:checked')?.value,
        synScan: document.querySelector('input[name="syn-scan"]').checked,
        versionScan: document.querySelector('input[name="version-scan"]').checked,
        osScan: document.querySelector('input[name="os-scan"]').checked,
        speed: document.querySelector('.select-field').value
    };

    console.log('Starting scan with parameters:', scanParams);

    // TODO: Send to backend via fetch/WebSocket
    // For now, show a placeholder message
    alert('Tarama başlatılıyor... (Backend entegrasyonu yapılacak)');
});

// Auto Fill Button
const autoFillBtn = document.querySelector('.btn-auto-fill');
autoFillBtn.addEventListener('click', () => {
    // Auto-fill with local network range (placeholder)
    document.querySelector('.input-field').value = '192.168.1.0/24';
    console.log('Auto-filled target range');
});

// Search Input
const searchInput = document.querySelector('.search-input');
searchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();

    deviceItems.forEach(device => {
        const deviceName = device.querySelector('.device-name').textContent.toLowerCase();
        if (deviceName.includes(searchTerm)) {
            device.style.display = 'flex';
        } else {
            device.style.display = 'none';
        }
    });
});

// Placeholder function for backend integration
function connectToBackend() {
    // TODO: Implement WebSocket or Server-Sent Events for real-time updates
    console.log('Backend connection will be implemented here');
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    console.log('Pentest Otomasyon Motoru initialized');
    updatePortSelectionState(); // Ensure correct initial state
    // connectToBackend(); // Will be enabled when backend is ready
});
