// Wait for DOM to be fully loaded before initializing
document.addEventListener('DOMContentLoaded', function () {
    console.log('DOM loaded, initializing app...');

    // Radio Button Logic - Host Discovery vs Port Selection
    const scanTypeRadios = document.querySelectorAll('input[name="scan-type"]');
    const portSelectionRadios = document.querySelectorAll('input[name="port-selection"]');

    // Add toggle functionality to radio buttons (click again to deselect)
    function makeRadioToggleable(radioButtons) {
        radioButtons.forEach(radio => {
            radio.addEventListener('click', function (e) {
                // If already checked, uncheck it
                if (this.dataset.wasChecked === 'true') {
                    this.checked = false;
                    this.dataset.wasChecked = 'false';
                    // Trigger change event to update dependent states
                    this.dispatchEvent(new Event('change'));
                } else {
                    // Mark all radios in this group as unchecked
                    radioButtons.forEach(r => r.dataset.wasChecked = 'false');
                    // Mark this one as checked
                    this.dataset.wasChecked = 'true';
                }
            });
        });
    }

    // Apply toggle functionality to both radio groups
    makeRadioToggleable(scanTypeRadios);
    makeRadioToggleable(portSelectionRadios);

    function updatePortSelectionState() {
        const hostDiscoveryRadio = document.querySelector('input[name="scan-type"][value="host"]');
        const hostDiscoverySelected = hostDiscoveryRadio?.checked;

        portSelectionRadios.forEach(radio => {
            if (hostDiscoverySelected) {
                // Disable port selection when Host Discovery is selected
                radio.disabled = true;
                radio.checked = false;
                radio.dataset.wasChecked = 'false';
                radio.parentElement.style.opacity = '0.5';
                radio.parentElement.style.cursor = 'not-allowed';
            } else {
                // Enable port selection for other scan types
                radio.disabled = false;
                radio.parentElement.style.opacity = '1';
                radio.parentElement.style.cursor = 'pointer';
            }
        });
    }

    // When port selection is made, auto-deselect host discovery
    portSelectionRadios.forEach(radio => {
        radio.addEventListener('change', () => {
            if (radio.checked) {
                const hostDiscoveryRadio = document.querySelector('input[name="scan-type"][value="host"]');
                if (hostDiscoveryRadio && hostDiscoveryRadio.checked) {
                    hostDiscoveryRadio.checked = false;
                    hostDiscoveryRadio.dataset.wasChecked = 'false';
                    updatePortSelectionState();
                }
            }
        });
    });

    // Listen to scan type changes
    scanTypeRadios.forEach(radio => {
        radio.addEventListener('change', updatePortSelectionState);
    });

    // Initialize on page load - port options enabled by default
    updatePortSelectionState();

    // AI Analysis Panel Toggle
    const aiToggleBtn = document.getElementById('aiToggleBtn');
    const aiAnalysisPanel = document.getElementById('aiAnalysisPanel');

    aiToggleBtn.addEventListener('click', () => {
        aiAnalysisPanel.classList.toggle('open');
        aiToggleBtn.classList.toggle('active');
    });

    // Device Selection
    const deviceItems = document.querySelectorAll('.device-item');
    deviceItems.forEach(device => {
        device.addEventListener('click', () => {
            // Remove selected class from all devices
            deviceItems.forEach(d => d.classList.remove('device-selected'));
            // Add selected class to clicked device
            device.classList.add('device-selected');

            // Update technical details (placeholder - will be dynamic with backend)
            const deviceName = device.querySelector('.device-name').textContent;
            document.querySelector('.details-header').textContent = `Teknik Detaylar: ${deviceName}`;
        });
    });

    // Vulnerability Item Selection
    const vulnItems = document.querySelectorAll('.vuln-item');
    const cveSeverityCard = document.getElementById('cveSeverityCard');

    vulnItems.forEach(item => {
        item.addEventListener('click', () => {
            // Remove selected class from all items
            vulnItems.forEach(v => v.classList.remove('vuln-selected'));
            // Add selected class to clicked item
            item.classList.add('vuln-selected');

            // Update CVE details (placeholder - will be dynamic with backend)
            const vulnText = item.textContent.trim();
            document.querySelector('.cve-header').textContent = vulnText;

            // Update CVE severity card color based on vulnerability type
            if (cveSeverityCard) {
                // Remove all severity classes
                cveSeverityCard.classList.remove('cve-card-critical', 'cve-card-medium', 'cve-card-low');

                // Add appropriate class based on selected vulnerability
                if (item.classList.contains('vuln-critical')) {
                    cveSeverityCard.classList.add('cve-card-critical');
                } else if (item.classList.contains('vuln-medium')) {
                    cveSeverityCard.classList.add('cve-card-medium');
                } else if (item.classList.contains('vuln-low')) {
                    cveSeverityCard.classList.add('cve-card-low');
                } else {
                    // Default to critical for general overview
                    cveSeverityCard.classList.add('cve-card-critical');
                }
            }
        });
    });

    // Filter Buttons
    const filterBtns = document.querySelectorAll('.filter-btn');
    filterBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // Remove active class from all filters
            filterBtns.forEach(b => b.classList.remove('filter-active'));
            // Add active class to clicked filter
            btn.classList.add('filter-active');

            // Filter logic will be implemented with backend data
            console.log('Filter clicked:', btn.textContent);
        });
    });

    // Start Scan Button - BACKEND INTEGRATION
    const startScanBtn = document.querySelector('.btn-start-scan');
    const devicesList = document.querySelector('.devices-list');
    let currentScanId = null;
    let pollInterval = null;
    let isScanning = false;

    startScanBtn.addEventListener('click', async () => {
        // If scanning, cancel the scan
        if (isScanning) {
            await cancelScan();
            return;
        }

        // Collect scan parameters
        const targets = document.querySelector('.input-field').value;

        if (!targets) {
            alert('Lütfen tarama hedefi girin (örn: 10.0.2.5 veya 10.0.2.0/24)');
            return;
        }

        const scanParams = {
            targets: targets,
            scanType: document.querySelector('input[name="scan-type"]:checked')?.value || 'host',
            portSelection: document.querySelector('input[name="port-selection"]:checked')?.value,
            synScan: document.querySelector('input[name="syn-scan"]')?.checked || false,
            versionScan: document.querySelector('input[name="version-scan"]')?.checked || false,
            osScan: document.querySelector('input[name="os-scan"]')?.checked || false,
            speed: document.querySelector('.select-field')?.value || 'normal'
        };

        console.log('Starting scan with parameters:', scanParams);

        try {
            // Change button to cancel mode
            isScanning = true;
            startScanBtn.classList.add('scanning');
            startScanBtn.textContent = 'İptal Et';

            // Clear previous results
            devicesList.innerHTML = '<div style="color: #CCD6F6; padding: 20px;">Tarama başlatılıyor...</div>';

            // Start scan
            const response = await fetch('/api/scan/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(scanParams)
            });

            const data = await response.json();

            if (data.success) {
                currentScanId = data.scan_id;
                devicesList.innerHTML = '<div style="color: #CCD6F6; padding: 20px;">⏳ Tarama devam ediyor...</div>';

                // Start polling for results
                pollScanStatus(currentScanId);
            } else {
                throw new Error(data.error || 'Tarama başlatılamadı');
            }
        } catch (error) {
            console.error('Scan error:', error);
            alert(`Hata: ${error.message}`);
            resetScanButton();
            devicesList.innerHTML = '<div style="color: #F50000; padding: 20px;">❌ Tarama başlatılamadı: ' + error.message + '</div>';
        }
    });

    // Cancel scan function
    async function cancelScan() {
        if (!currentScanId) return;

        try {
            const response = await fetch(`/api/scan/cancel/${currentScanId}`, {
                method: 'POST'
            });

            const data = await response.json();

            if (data.success) {
                devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">⚠️ Tarama iptal edildi</div>';
            } else {
                alert(`İptal hatası: ${data.error}`);
            }
        } catch (error) {
            console.error('Cancel error:', error);
            alert(`İptal hatası: ${error.message}`);
        } finally {
            resetScanButton();
            if (pollInterval) {
                clearInterval(pollInterval);
            }
        }
    }

    // Reset scan button to initial state
    function resetScanButton() {
        isScanning = false;
        startScanBtn.classList.remove('scanning');
        startScanBtn.textContent = 'Taramayı Başlat';
        startScanBtn.disabled = false;
    }

    // Poll scan status and results
    function pollScanStatus(scanId) {
        // Clear any existing interval
        if (pollInterval) {
            clearInterval(pollInterval);
        }

        // Poll every 2 seconds
        pollInterval = setInterval(async () => {
            try {
                const response = await fetch(`/api/scan/status/${scanId}`);
                const data = await response.json();

                if (data.success) {
                    const status = data.status;

                    if (status === 'completed') {
                        // Scan completed, get results
                        clearInterval(pollInterval);
                        await loadScanResults(scanId);
                        resetScanButton();
                    } else if (status === 'failed') {
                        // Scan failed
                        clearInterval(pollInterval);
                        devicesList.innerHTML = `<div style="color: #F50000; padding: 20px;">❌ Tarama başarısız: ${data.error}</div>`;
                        resetScanButton();
                    } else if (status === 'cancelled') {
                        // Scan cancelled
                        clearInterval(pollInterval);
                        devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">⚠️ Tarama iptal edildi</div>';
                        resetScanButton();
                    } else {
                        // Still running - show incremental results
                        const devicesFound = data.devices_found || 0;

                        // Try to get partial results
                        try {
                            const resultsResponse = await fetch(`/api/scan/results/${scanId}`);
                            const resultsData = await resultsResponse.json();

                            if (resultsData.success && resultsData.devices && resultsData.devices.length > 0) {
                                // Display partial results
                                displayDevicesIncremental(resultsData.devices, true);
                            } else {
                                devicesList.innerHTML = `<div style="color: #CCD6F6; padding: 20px;">⏳ Tarama devam ediyor... (${devicesFound} cihaz bulundu)</div>`;
                            }
                        } catch (e) {
                            devicesList.innerHTML = `<div style="color: #CCD6F6; padding: 20px;">⏳ Tarama devam ediyor... (${devicesFound} cihaz bulundu)</div>`;
                        }
                    }
                }
            } catch (error) {
                console.error('Status poll error:', error);
            }
        }, 500);  // Poll every 500ms for faster updates
    }

    // Load and display scan results
    async function loadScanResults(scanId) {
        try {
            const response = await fetch(`/api/scan/results/${scanId}`);
            const data = await response.json();

            if (data.success && data.devices && data.devices.length > 0) {
                displayDevices(data.devices);
            } else {
                devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">⚠️ Tarama tamamlandı, ancak cihaz bulunamadı.</div>';
            }
        } catch (error) {
            console.error('Results load error:', error);
            devicesList.innerHTML = '<div style="color: #F50000; padding: 20px;">❌ Sonuçlar yüklenemedi</div>';
        }
    }

    // Display devices in the UI
    function displayDevices(devices) {
        devicesList.innerHTML = '';

        devices.forEach((device, index) => {
            const deviceItem = document.createElement('div');
            deviceItem.className = 'device-item';
            if (index === 0) deviceItem.classList.add('device-selected');

            // Get device icon
            const iconInfo = getDeviceIcon(device.hostname || device.ip, device.os || '');

            // Count vulnerabilities (placeholder for now)
            const vulnCounts = device.vulnerabilities || { critical: 0, medium: 0, low: 0 };
            const portCount = device.ports ? device.ports.length : 0;

            deviceItem.innerHTML = `
            <div class="device-icon">
                <img src="${iconInfo.src}" alt="${iconInfo.alt}" class="device-icon-img" 
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
                <span class="device-icon-fallback" style="display:none;">${iconInfo.fallback}</span>
            </div>
            <div class="device-info">
                <div class="device-name">${device.ip} (${device.hostname})</div>
                <div class="device-stats">
                    ${vulnCounts.critical > 0 ? `<span class="stat-critical">🔥 Kritik: ${vulnCounts.critical}</span>` : ''}
                    ${vulnCounts.medium > 0 ? `<span class="stat-medium">🟠 Orta: ${vulnCounts.medium}</span>` : ''}
                    ${vulnCounts.low > 0 ? `<span class="stat-low">🟡 Düşük: ${vulnCounts.low}</span>` : ''}
                    ${portCount > 0 ? `<span class="stat-safe">🟢 Port: ${portCount}</span>` : '<span class="stat-safe">🟢 Aktif</span>'}
                </div>
            </div>
            <div class="device-arrow">></div>
        `;

            // Store device data
            deviceItem.dataset.deviceData = JSON.stringify(device);

            // Add click handler
            deviceItem.addEventListener('click', () => {
                document.querySelectorAll('.device-item').forEach(d => d.classList.remove('device-selected'));
                deviceItem.classList.add('device-selected');
                displayTechnicalDetails(device);
            });

            devicesList.appendChild(deviceItem);
        });

        // Display first device details
        if (devices.length > 0) {
            displayTechnicalDetails(devices[0]);
        }
    }

    // Display technical details for selected device
    function displayTechnicalDetails(device) {
        const detailsHeader = document.querySelector('.details-header');
        const detailsTerminal = document.querySelector('.details-terminal');

        detailsHeader.textContent = `Teknik Detaylar: ${device.ip} (${device.hostname})`;

        if (device.ports && device.ports.length > 0) {
            let html = `
            <div style="margin-bottom: 20px; display: flex; justify-content: flex-end;">
                <button onclick='analyzeWithAI(${JSON.stringify(device)})' class="btn-ai-analyze" style="
                    background: linear-gradient(90deg, #7928CA, #FF0080);
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    color: white;
                    font-weight: 600;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-family: 'Inter', sans-serif;
                    box-shadow: 0 4px 12px rgba(121, 40, 202, 0.3);
                    transition: transform 0.2s;
                ">
                    ✨ AI ile Zafiyet Analizi
                </button>
            </div>
            <div id="ai-analysis-result" style="margin-bottom: 20px; display: none;"></div>
            <div class="terminal-row">
                <div class="terminal-label">PORT</div>
                <div class="terminal-label">STATE</div>
                <div class="terminal-label">SERVICE</div>
                <div class="terminal-label">VERSION</div>
            </div>
        `;

            device.ports.forEach(port => {
                html += `
                <div class="terminal-row">
                    <div class="terminal-value">${port.port}/${port.protocol}</div>
                    <div class="terminal-value" style="color: #38C271;">${port.state}</div>
                    <div class="terminal-value" style="color: #63B3ED;">${port.service || 'unknown'}</div>
                    <div class="terminal-value">${port.version || port.product || '-'}</div>
                </div>
            `;
            });

            detailsTerminal.innerHTML = html;
        } else {
            detailsTerminal.innerHTML = `
            <div style="margin-bottom: 20px; display: flex; justify-content: flex-end;">
                <button onclick='analyzeWithAI(${JSON.stringify(device)})' class="btn-ai-analyze" style="
                    background: linear-gradient(90deg, #7928CA, #FF0080);
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    color: white;
                    font-weight: 600;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-family: 'Inter', sans-serif;
                ">
                    ✨ AI ile Zafiyet Analizi
                </button>
            </div>
            <div id="ai-analysis-result" style="margin-bottom: 20px; display: none;"></div>
            <div class="terminal-row">
                <div class="terminal-label">PORT</div>
                <div class="terminal-label">STATE</div>
                <div class="terminal-label">SERVICE</div>
                <div class="terminal-label">VERSION</div>
            </div>
            <div style="color: #CCD6F6; padding: 20px;">Açık port bulunamadı (Host Discovery modu)</div>
        `;
        }
    }

    // AI Analysis Function
    async function analyzeWithAI(device) {
        const aiPanel = document.getElementById('aiAnalysisPanel');
        const btn = event.target;

        // Show loading
        btn.disabled = true;
        btn.innerHTML = '⏳ Analiz yapılıyor...';
        btn.style.opacity = '0.8';

        // Show AI panel with loading state
        aiPanel.style.display = 'block';
        aiPanel.innerHTML = `
        <div class="ai-loading" style="text-align: center; padding: 40px; color: #CCD6F6;">
            <div style="font-size: 2em; margin-bottom: 10px;">🤖</div>
            <div>Gemini AI cihazı analiz ediyor...</div>
            <div style="font-size: 0.9em; color: #888D9D; margin-top: 10px;">Bu işlem birkaç saniye sürebilir</div>
        </div>
    `;

        try {
            const response = await fetch('/api/analyze/device', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(device)
            });

            const data = await response.json();

            if (data.success) {
                const analysis = data.analysis;

                // Update toggle button title with hostname
                const displayName = device.hostname && device.hostname !== 'N/A' && device.hostname !== device.ip
                    ? `${device.hostname} [${device.ip}]`
                    : device.ip;
                document.getElementById('aiPanelTitle').textContent = `Yapay Zeka Güvenlik Analizi: ${displayName}`;

                // Store analysis data globally for selection
                window.currentAnalysis = analysis;
                window.currentDevice = device;

                // Build AI panel
                buildAIPanel(analysis, device);
            } else {
                aiPanel.innerHTML = `
                <div style="background: rgba(245, 0, 0, 0.1); border: 1px solid #F50000; border-radius: 8px; padding: 20px; text-align: center;">
                    <div style="color: #F50000; font-size: 1.2em;">⚠️ Analiz Hatası</div>
                    <div style="color: #CCD6F6; margin-top: 10px;">${data.error}</div>
                </div>
            `;
            }
        } catch (error) {
            console.error('AI Error:', error);
            aiPanel.innerHTML = `
            <div style="background: rgba(245, 0, 0, 0.1); border: 1px solid #F50000; border-radius: 8px; padding: 20px; text-align: center;">
                <div style="color: #F50000; font-size: 1.2em;">⚠️ Bağlantı Hatası</div>
                <div style="color: #CCD6F6; margin-top: 10px;">${error.message}</div>
            </div>
        `;
        } finally {
            btn.disabled = false;
            btn.innerHTML = '✨ AI ile Tekrar Analiz Et';
            btn.style.opacity = '1';
        }
    }

    function buildAIPanel(analysis, device) {
        const aiPanel = document.getElementById('aiAnalysisPanel');

        // Build vulnerability list items
        let vulnListHtml = `
        <button class="vuln-item vuln-general vuln-selected" onclick="selectVulnerability('general')">
            🛡️ Genel Özet
        </button>
    `;

        if (analysis.vulnerabilities && analysis.vulnerabilities.length > 0) {
            analysis.vulnerabilities.forEach((vuln, index) => {
                const severityClass = getSeverityClass(vuln.severity);
                vulnListHtml += `
                <button class="vuln-item ${severityClass}" onclick="selectVulnerability(${index})">
                    ${vuln.title}
                </button>
            `;
            });
        }

        // Build panel HTML (no header, just content)
        aiPanel.innerHTML = `
        <div class="ai-content">
            <!-- Left: Vulnerability List -->
            <div class="vulnerability-list">
                <h3 class="vuln-list-title">Zafiyet Listesi</h3>
                <div class="vuln-items">
                    ${vulnListHtml}
                </div>
            </div>

            <!-- Right: CVE Details -->
            <div class="cve-details" id="cveDetailsPanel">
                <!-- Will be populated by selectVulnerability() -->
            </div>
        </div>
    `;

        // Select general overview by default
        selectVulnerability('general');
    }

    function selectVulnerability(index) {
        const analysis = window.currentAnalysis;
        const device = window.currentDevice;
        const detailsPanel = document.getElementById('cveDetailsPanel');

        // Update selected state in list
        document.querySelectorAll('.vuln-item').forEach(item => {
            item.classList.remove('vuln-selected');
        });

        if (index === 'general') {
            // Show general overview
            document.querySelector('.vuln-general').classList.add('vuln-selected');

            const riskColor = getRiskColor(analysis.risk_score);
            const riskLevel = analysis.risk_level || getRiskLevel(analysis.risk_score);

            detailsPanel.innerHTML = `
            <div class="cve-header">Genel Güvenlik Özeti</div>
            
            <div class="cve-cards">
                <!-- Risk Score Card -->
                <div class="cve-card cve-card-${riskLevel.toLowerCase()}">
                    <div class="cve-card-title">${riskLevel.toUpperCase()}</div>
                    <div class="cve-risk-label">Risk Puanı</div>
                    <div class="cve-risk-score">${analysis.risk_score}/10</div>
                    <div class="cve-risk-type">Genel Değerlendirme</div>
                </div>

                <!-- Summary Card -->
                <div class="cve-card cve-card-analysis">
                    <div class="cve-card-title-analysis">Özet Analiz</div>
                    <div class="cve-analysis-text">
                        ${analysis.summary}
                    </div>
                </div>

                <!-- Recommendations Card -->
                <div class="cve-card cve-card-recommendations">
                    <div class="cve-card-title-recommendations">Önerilen Adımlar</div>
                    <ul class="cve-recommendations-list">
                        ${analysis.recommendations && analysis.recommendations.length > 0
                    ? analysis.recommendations.map(r => `<li>${r}</li>`).join('')
                    : '<li>Tespit edilen zafiyetleri inceleyin ve gerekli güncellemeleri yapın.</li>'}
                    </ul>
                </div>
            </div>
        `;
        } else {
            // Show specific vulnerability
            const vuln = analysis.vulnerabilities[index];
            document.querySelectorAll('.vuln-item')[index + 1].classList.add('vuln-selected');

            const severityClass = getSeverityClass(vuln.severity);
            const severityColor = getSeverityColor(vuln.severity);

            detailsPanel.innerHTML = `
            <div class="cve-header">${vuln.title}</div>
            
            <div class="cve-cards">
                <!-- Severity Card -->
                <div class="cve-card cve-card-${severityClass}">
                    <div class="cve-card-title">${vuln.severity.toUpperCase()}</div>
                    <div class="cve-risk-label">Risk Puanı</div>
                    <div class="cve-risk-score">${vuln.cvss_score || 'N/A'}/10</div>
                    <div class="cve-risk-type">Port: ${vuln.affected_port || 'N/A'}</div>
                </div>

                <!-- Description Card -->
                <div class="cve-card cve-card-analysis">
                    <div class="cve-card-title-analysis">Risk Analizi</div>
                    <div class="cve-analysis-text">
                        ${vuln.description}
                    </div>
                </div>

                <!-- Recommendations Card -->
                <div class="cve-card cve-card-recommendations">
                    <div class="cve-card-title-recommendations">Önerilen Adımlar</div>
                    <ul class="cve-recommendations-list">
                        ${analysis.recommendations && analysis.recommendations.length > 0
                    ? analysis.recommendations.slice(0, 3).map(r => `<li>${r}</li>`).join('')
                    : '<li>İlgili servisi güncelleyin veya devre dışı bırakın.</li>'}
                    </ul>
                </div>
            </div>
        `;
        }
    }

    // Helper functions
    function getSeverityClass(severity) {
        const sev = severity.toLowerCase();
        if (sev === 'critical') return 'vuln-critical';
        if (sev === 'high') return 'vuln-high';
        if (sev === 'medium') return 'vuln-medium';
        return 'vuln-low';
    }

    function getSeverityColor(severity) {
        const sev = severity.toLowerCase();
        if (sev === 'critical') return '#F50000';
        if (sev === 'high') return '#F59E0B';
        if (sev === 'medium') return '#FFE100';
        return '#38C271';
    }

    function getRiskColor(score) {
        if (score >= 9.0) return '#F50000';
        if (score >= 7.0) return '#F59E0B';
        if (score >= 4.0) return '#FFE100';
        return '#38C271';
    }

    function getRiskLevel(score) {
        if (score >= 9.0) return 'Critical';
        if (score >= 7.0) return 'High';
        if (score >= 4.0) return 'Medium';
        return 'Low';
    }

    // Auto Fill Button
    const autoFillBtn = document.querySelector('.btn-auto-fill');
    if (autoFillBtn) {
        autoFillBtn.addEventListener('click', () => {
            // Auto-fill with local network range (placeholder)
            const inputField = document.querySelector('.input-field');
            if (inputField) {
                inputField.value = '10.0.2.0/24';
                console.log('Auto-filled target range');
            }
        });
    }

    // Search Input
    const searchInput = document.querySelector('.search-input');
    if (searchInput) {
        searchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();

            document.querySelectorAll('.device-item').forEach(device => {
                const deviceName = device.querySelector('.device-name').textContent.toLowerCase();
                if (deviceName.includes(searchTerm)) {
                    device.style.display = 'flex';
                } else {
                    device.style.display = 'none';
                }
            });
        });
    }


    // ===== TAB SWITCHING LOGIC =====
    // (Tab switching handlers are at the end of the file)


    // ===== WEB SCAN LOGIC =====
    // (Conditional input handlers are at the end of the file)

    // Web scan start button

    // Wordlist file upload button
    const wordlistUploadBtn = document.getElementById('wordlist-upload-btn');
    const wordlistFileInput = document.getElementById('wordlist-file-input');
    const wordlistUploadCheckbox = document.getElementById('wordlist-upload-enabled');

    // Toggle upload button based on checkbox
    if (wordlistUploadCheckbox && wordlistUploadBtn) {
        // Initial state sync
        wordlistUploadBtn.disabled = !wordlistUploadCheckbox.checked;

        wordlistUploadCheckbox.addEventListener('change', function () {
            wordlistUploadBtn.disabled = !this.checked;
        });
    }

    if (wordlistUploadBtn) {
        wordlistUploadBtn.addEventListener('click', () => {
            wordlistFileInput.click();
        });
    }

    // Handle wordlist file selection
    if (wordlistFileInput) {
        wordlistFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const wordlistManual = document.getElementById('wordlist-manual');
                    if (wordlistManual) {
                        wordlistManual.value = event.target.result;
                        alert(`Wordlist yüklendi: ${file.name} (${file.size} bytes)`);
                    }
                };
                reader.onerror = (error) => {
                    console.error('File read error:', error);
                    alert('Dosya okuma hatası!');
                };
                reader.readAsText(file);
            }
        });
    }

    // Web Scan Start Button
    const webScanStartBtn = document.getElementById('web-scan-start');
    let currentWebScanId = null;
    let webScanPollInterval = null;
    let isWebScanning = false;

    if (webScanStartBtn) {
        webScanStartBtn.addEventListener('click', async () => {
            // If scanning, cancel the scan
            if (isWebScanning) {
                await cancelWebScan();
                return;
            }

            // Collect scan parameters
            const targetUrl = document.getElementById('web-target-url').value;

            if (!targetUrl) {
                alert('Lütfen hedef URL girin (örn: https://example.com)');
                return;
            }

            const gobusterEnabled = document.getElementById('gobuster-enabled').checked;
            const niktoEnabled = document.getElementById('nikto-enabled').checked;

            if (!gobusterEnabled && !niktoEnabled) {
                alert('Lütfen en az bir tarama türü seçin (Gobuster veya Nikto)');
                return;
            }

            // Determine recursive mode
            let recursiveMode = 'base';
            if (niktoEnabled && document.getElementById('nikto-recursive').checked) {
                const recursiveRadios = document.getElementsByName('recursive-mode');
                for (const radio of recursiveRadios) {
                    if (radio.checked) {
                        recursiveMode = radio.value;
                        break;
                    }
                }
            }

            const webScanParams = {
                target_url: targetUrl,
                gobuster: {
                    enabled: gobusterEnabled,
                    threads: gobusterEnabled ? (document.getElementById('gobuster-threads').value || '10') : null,
                    delay: gobusterEnabled ? (document.getElementById('gobuster-delay').value || '0') : null
                },
                nikto: {
                    enabled: niktoEnabled,
                    scan_type: niktoEnabled ? document.getElementById('nikto-scan-type').value : null,
                    delay: niktoEnabled ? (document.getElementById('nikto-delay').value || '0') : null,
                    recursive: niktoEnabled ? document.getElementById('nikto-recursive').checked : false
                },
                ssl_enforce: document.getElementById('ssl-enforce').checked,
                recursive: niktoEnabled ? document.getElementById('nikto-recursive').checked : false,
                recursive_mode: recursiveMode,
                wordlist: document.getElementById('wordlist-manual').value
            };

            console.log('Starting web scan with parameters:', webScanParams);

            try {
                // Change button to cancel mode
                isWebScanning = true;
                webScanStartBtn.classList.add('scanning');
                webScanStartBtn.textContent = 'İptal Et';

                // Clear previous results
                const webTableBody = document.getElementById('web-table-body');
                webTableBody.innerHTML = '<div style="color: #CCD6F6; padding: 20px; text-align: center;">Tarama başlatılıyor...</div>';

                // Clear Nikto terminal
                const niktoTerminal = document.getElementById('nikto-terminal');
                niktoTerminal.innerHTML = '<div style="color: #888D9D; font-style: italic;">Tarama başlatılıyor...</div>';

                // Start scan via API
                const response = await fetch('/api/webscan/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(webScanParams)
                });

                const data = await response.json();

                if (data.success) {
                    currentWebScanId = data.scan_id;
                    // Start polling for results
                    pollWebScanStatus(currentWebScanId);
                } else {
                    throw new Error(data.error || 'Web taraması başlatılamadı');
                }
            } catch (error) {
                console.error('Web scan error:', error);
                alert(`Hata: ${error.message}`);
                resetWebScanButton();
            }
        });
    }

    // Poll web scan status
    function pollWebScanStatus(scanId) {
        webScanPollInterval = setInterval(async () => {
            try {
                const response = await fetch(`/api/webscan/status/${scanId}`);
                const data = await response.json();

                if (!data.success) {
                    clearInterval(webScanPollInterval);
                    alert(`Tarama hatası: ${data.error}`);
                    resetWebScanButton();
                    return;
                }

                // Update Gobuster results
                if (data.gobuster && data.gobuster.enabled) {
                    updateGobusterResults(data.gobuster.results);
                }

                // Update Nikto output
                if (data.nikto && data.nikto.enabled) {
                    updateNiktoOutput(data.nikto.output);
                }

                // Check if scan is completed
                if (data.status === 'completed' || data.status === 'error' || data.status === 'cancelled') {
                    clearInterval(webScanPollInterval);
                    resetWebScanButton();

                    if (data.status === 'error') {
                        alert('Tarama sırasında hata oluştu');
                    }
                }

            } catch (error) {
                console.error('Polling error:', error);
                clearInterval(webScanPollInterval);
                resetWebScanButton();
            }
        }, 1000); // Poll every second
    }

    // Update Gobuster results in table
    function updateGobusterResults(results) {
        const webTableBody = document.getElementById('web-table-body');

        if (!results || results.length === 0) {
            webTableBody.innerHTML = '<div style="color: #888D9D; padding: 20px; text-align: center;">Henüz sonuç bulunamadı...</div>';
            return;
        }

        webTableBody.innerHTML = '';

        results.forEach(result => {
            const row = document.createElement('div');
            row.className = 'table-row';

            row.innerHTML = `
            <div class="table-cell path">${result.path}</div>
            <div class="table-cell status status-${result.status}">${result.status}</div>
            <div class="table-cell">${result.size}</div>
            <div class="table-cell">${result.type}</div>
        `;

            webTableBody.appendChild(row);
        });
    }

    // Update Nikto output in terminal
    function updateNiktoOutput(outputLines) {
        const niktoTerminal = document.getElementById('nikto-terminal');

        if (!outputLines || outputLines.length === 0) {
            niktoTerminal.innerHTML = '<div style="color: #888D9D; font-style: italic;">Tarama devam ediyor...</div>';
            return;
        }

        niktoTerminal.innerHTML = '';

        outputLines.forEach(line => {
            const lineDiv = document.createElement('div');
            lineDiv.className = `nikto-line nikto-${line.type}`;
            lineDiv.textContent = line.message;
            niktoTerminal.appendChild(lineDiv);
        });

        // Auto-scroll to bottom
        niktoTerminal.scrollTop = niktoTerminal.scrollHeight;
    }

    // Cancel web scan function
    async function cancelWebScan() {
        if (!currentWebScanId) {
            resetWebScanButton();
            return;
        }

        try {
            const response = await fetch(`/api/webscan/cancel/${currentWebScanId}`, {
                method: 'POST'
            });

            const data = await response.json();

            if (data.success) {
                const webTableBody = document.getElementById('web-table-body');
                webTableBody.innerHTML = '<div style="color: #FFE100; padding: 20px; text-align: center;">⚠️ Tarama iptal edildi</div>';
            } else {
                alert(`İptal hatası: ${data.error}`);
            }
        } catch (error) {
            console.error('Cancel error:', error);
            alert(`İptal hatası: ${error.message}`);
        } finally {
            resetWebScanButton();
            if (webScanPollInterval) {
                clearInterval(webScanPollInterval);
            }
        }
    }

    // Reset web scan button to initial state
    function resetWebScanButton() {
        isWebScanning = false;
        webScanStartBtn.classList.remove('scanning');
        webScanStartBtn.textContent = 'Taramayı Başlat';
        webScanStartBtn.disabled = false;
    }

    // Web scan filter buttons
    const webFilterBtns = document.querySelectorAll('#web-scan-content .filter-btn');
    webFilterBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // Remove active class from all filters
            webFilterBtns.forEach(b => b.classList.remove('filter-active'));
            // Add active class to clicked filter
            btn.classList.add('filter-active');

            const filter = btn.dataset.filter;
            console.log('Web filter clicked:', filter);

            // TODO: Implement filtering logic
            // Filter table rows based on status code
        });
    });

    // Web scan search input
    const webSearchInput = document.getElementById('web-search-input');
    if (webSearchInput) {
        webSearchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();

            document.querySelectorAll('.table-row').forEach(row => {
                const pathCell = row.querySelector('.table-cell.path');
                if (pathCell) {
                    const path = pathCell.textContent.toLowerCase();
                    if (path.includes(searchTerm)) {
                        row.style.display = 'grid';
                    } else {
                        row.style.display = 'none';
                    }
                }
            });
        });
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        console.log('Pentest Otomasyon Motoru initialized');
        updatePortSelectionState(); // Ensure correct initial state
    });

    // ===== WEB SCAN AI ANALYSIS TOGGLE =====
    // Logic moved to end of file with enhanced scrolling support


    // ===== WEB SCAN AI PATH-BASED ANALYSIS =====
    function initWebAiPathAnalysis() {
        // Path Selection Handler
        const pathButtons = document.querySelectorAll('.path-btn');
        pathButtons.forEach(btn => {
            btn.addEventListener('click', function () {
                // Remove selected class from all paths
                pathButtons.forEach(b => b.classList.remove('path-selected'));

                // Add selected class to clicked path
                this.classList.add('path-selected');

                // Get path data
                const pathData = this.dataset.path;

                // Update content based on selected path
                if (pathData === 'master') {
                    displayMasterPathAnalysis();
                } else {
                    displayPathAnalysis(pathData);
                }
            });
        });

        // Initialize with Master Path view by default
        displayMasterPathAnalysis();

        // Vulnerability Row Selection Handler
        const vulnTable = document.getElementById('webVulnsTableBody');
        if (vulnTable) {
            vulnTable.addEventListener('click', function (e) {
                const row = e.target.closest('.vuln-row');
                if (!row) return;

                // Remove selected class from all rows
                document.querySelectorAll('.vuln-row').forEach(r => {
                    r.classList.remove('vuln-row-selected');
                });

                // Add selected class to clicked row
                row.classList.add('vuln-row-selected');

                // Get vulnerability data
                const vulnId = row.dataset.vuln;
                displayVulnerabilityDetails(vulnId);
            });
        }

        // Path Search Handler
        const pathSearch = document.getElementById('webPathSearch');
        if (pathSearch) {
            pathSearch.addEventListener('input', function () {
                const searchTerm = this.value.toLowerCase();
                const dynamicPaths = document.querySelectorAll('#webDynamicPaths .path-btn');

                dynamicPaths.forEach(btn => {
                    const pathText = btn.querySelector('.path-text').textContent.toLowerCase();
                    if (pathText.includes(searchTerm)) {
                        btn.style.display = 'flex';
                    } else {
                        btn.style.display = 'none';
                    }
                });
            });
        }
    }

    function displayMasterPathAnalysis() {
        // Hide vulnerability table column
        const vulnsColumn = document.querySelector('.web-ai-vulns');
        if (vulnsColumn) {
            vulnsColumn.style.display = 'none';
        }

        // Adjust grid to make attack path larger and centered
        const grid = document.querySelector('.web-ai-grid');
        if (grid) {
            // Original: 250px 2fr 2fr
            // New: Larger Attack Path (Left), Smaller Recs (Right)
            grid.style.gridTemplateColumns = '260px 1.8fr 1.2fr';
        }

        // Update attack path header with gradient
        const attackHeader = document.querySelector('.web-ai-attack-header');
        if (attackHeader) {
            attackHeader.innerHTML = '<span style="background: linear-gradient(90deg, #00E6FF 20%, #8008CF 83%); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">MASTER PATH</span>';
        }

        // Update attack path content and alignment (Master Path: Center)
        const attackBody = document.getElementById('webAttackBody');
        if (attackBody) {
            attackBody.style.textAlign = 'center';
            attackBody.innerHTML = `
            <div style="margin-bottom: 16px; font-weight: 600; text-align: center;">Saldırı Yolu</div>
            <p style="margin-bottom: 12px; text-align: center;">Sistem genelinde yapılan detaylı taramalar ile birlikte saldırganın sisteme sızabileceği en kritik ve etkili saldırı yolu:</p>
            <ol class="attack-steps">
                <li>1)................</li>
                <li>2)................</li>
                <li>3)................</li>
                <li>4)................</li>
            </ol>
        `;
        }

        // Update recommendations
        const recBody = document.getElementById('webRecommendationsBody');
        if (recBody) {
            recBody.innerHTML = `
            <div style="margin-bottom: 16px; font-weight: 600; text-align: center;">Sistem Genelindeki açıklar için Önerilen Düzeltme Adımları</div>
            <ol class="recommendation-steps">
                <li>1)...........</li>
                <li>2)...........</li>
            </ol>
        `;
        }
    }

    function displayPathAnalysis(pathName) {
        // Show vulnerability table column
        const vulnsColumn = document.querySelector('.web-ai-vulns');
        if (vulnsColumn) {
            vulnsColumn.style.display = 'block';
        }

        // Reset grid to normal
        const grid = document.querySelector('.web-ai-grid');
        if (grid) {
            grid.style.gridTemplateColumns = '260px 280px 1.2fr 1.2fr'; // Match CSS
        }

        // Reset Attack Header


        // Reset Attack Header
        const attackHeader = document.querySelector('.web-ai-attack-header');
        if (attackHeader) {
            attackHeader.textContent = 'Saldırı Yolu';
            attackHeader.style.color = '#90CDF4';
            attackHeader.style.background = 'transparent';
        }

        // Update attack path for specific path (Left Align)
        const attackBody = document.getElementById('webAttackBody');
        if (attackBody) {
            attackBody.style.textAlign = 'left';
            attackBody.innerHTML = `
            <ol class="attack-steps">
                <li>X açığını sömürmek için</li>
                <li>...</li>
                <li>...</li>
                <li>...</li>
            </ol>
        `;
        }

        // Update recommendations for specific path
        const recBody = document.getElementById('webRecommendationsBody');
        if (recBody) {
            recBody.innerHTML = `
            <ol class="recommendation-steps">
                <li>1)...........</li>
                <li>2)...........</li>
            </ol>
        `;
        }
    }

    function displayVulnerabilityDetails(vulnId) {
        // Update attack path based on selected vulnerability
        const attackBody = document.getElementById('webAttackBody');
        if (attackBody) {
            attackBody.innerHTML = `
            <ol class="attack-steps">
                <li>Seçili açığı sömürmek için adım 1</li>
                <li>Adım 2...</li>
                <li>Adım 3...</li>
                <li>AdÄ±m 4...</li>
            </ol>
        `;
        }

        // Update recommendations based on selected vulnerability
        const recBody = document.getElementById('webRecommendationsBody');
        if (recBody) {
            recBody.innerHTML = `
            <ol class="recommendation-steps">
                <li>Bu aÃ§Ä±ÄŸÄ± kapatmak iÃ§in Ã¶neri 1</li>
                <li>Ã–neri 2...</li>
            </ol>
        `;
        }
    }

    // Initialize on page load
    // Initialize Web AI Path Analysis
    initWebAiPathAnalysis();

    // ===== TAB SWITCHING =====
    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');

    tabButtons.forEach(btn => {
        btn.addEventListener('click', function () {
            const targetTab = this.dataset.tab;

            // Remove active class from all tabs and buttons
            tabButtons.forEach(b => b.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));

            // Add active class to clicked button
            this.classList.add('active');

            // Show corresponding tab content
            const targetContent = document.getElementById(targetTab + '-content');
            if (targetContent) {
                targetContent.classList.add('active');
            }
        });
    });

    // ===== WEB SCAN CONDITIONAL INPUTS =====
    // Gobuster checkbox handler
    const gobusterCheckbox = document.getElementById('gobuster-enabled');
    const gobusterOptions = document.getElementById('gobuster-options');
    const gobusterThreads = document.getElementById('gobuster-threads');
    const gobusterDelay = document.getElementById('gobuster-delay');

    console.log('Gobuster elements:', {
        checkbox: !!gobusterCheckbox,
        options: !!gobusterOptions,
        threads: !!gobusterThreads,
        delay: !!gobusterDelay
    });

    if (gobusterCheckbox) {
        console.log('Attaching gobuster change listener...');
        gobusterCheckbox.addEventListener('change', function () {
            console.log('Gobuster checkbox changed:', this.checked);
            if (this.checked) {
                gobusterOptions.style.display = 'block';
                gobusterThreads.disabled = false;
                gobusterDelay.disabled = false;
            } else {
                gobusterOptions.style.display = 'none';
                gobusterThreads.disabled = true;
                gobusterDelay.disabled = true;
            }
        });
    } else {
        console.error('gobuster-enabled checkbox NOT FOUND!');
    }

    // Nikto checkbox handler
    // Nikto checkbox handler
    const niktoCheckbox = document.getElementById('nikto-enabled');
    const niktoOptions = document.getElementById('nikto-options');
    const niktoScanType = document.getElementById('nikto-scan-type');
    const niktoDelay = document.getElementById('nikto-delay');
    const niktoRecursive = document.getElementById('nikto-recursive');
    const recursiveModeOptions = document.getElementById('recursive-mode-options');

    // Helper to toggle recursive mode options
    function toggleRecursiveOptions() {
        if (niktoRecursive && niktoRecursive.checked && !niktoRecursive.disabled) {
            if (recursiveModeOptions) recursiveModeOptions.style.display = 'block';
        } else {
            if (recursiveModeOptions) recursiveModeOptions.style.display = 'none';
        }
    }

    if (niktoCheckbox) {
        niktoCheckbox.addEventListener('change', function () {
            if (this.checked) {
                niktoOptions.style.display = 'block';
                niktoScanType.disabled = false;
                niktoDelay.disabled = false;
                if (niktoRecursive) niktoRecursive.disabled = false;
            } else {
                niktoOptions.style.display = 'none';
                niktoScanType.disabled = true;
                niktoDelay.disabled = true;
                if (niktoRecursive) {
                    niktoRecursive.disabled = true;
                    niktoRecursive.checked = false;
                }
            }
            toggleRecursiveOptions();
        });
    }

    if (niktoRecursive) {
        niktoRecursive.addEventListener('change', toggleRecursiveOptions);
    }

    // Web AI Panel Toggle (for Web Scan tab)
    const webScanAiToggleBtn = document.getElementById('webAiToggleBtn');
    const webScanAiPanel = document.getElementById('webAiAnalysisPanel');

    if (webScanAiToggleBtn && webScanAiPanel) {
        webScanAiToggleBtn.addEventListener('click', function () {
            // Toggle logic using class for smooth transition
            webScanAiPanel.classList.toggle('open');
            webScanAiToggleBtn.classList.toggle('active');

            const isOpen = webScanAiPanel.classList.contains('open');
            console.log(isOpen ? '✅ Web AI panel opened' : '✅ Web AI panel closed');

            // Scroll to panel if opening
            if (isOpen) {
                setTimeout(() => {
                    webScanAiPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 300);
            }
        });
    }
    // Wordlist radio buttons handler
    const wordlistRadios = document.querySelectorAll('input[name="wordlist-type"]');
    const wordlistInput = document.getElementById('wordlistInput');
    const wordlistUpload = document.getElementById('wordlistUpload');

    wordlistRadios.forEach(radio => {
        radio.addEventListener('change', function () {
            if (this.value === 'input') {
                if (wordlistInput) wordlistInput.style.display = 'block';
                if (wordlistUpload) wordlistUpload.style.display = 'none';
            } else {
                if (wordlistInput) wordlistInput.style.display = 'none';
                if (wordlistUpload) wordlistUpload.style.display = 'block';
            }
        });
    });

    // ===== SCAN MODE UI SWITCHING =====
    function switchWebScanAiMode() {
        // Toggle Panels
        const standardGrid = document.getElementById('webStandardGrid');
        const gobusterGrid = document.getElementById('webGobusterGrid');

        // Logic: specific to "Only Gobuster" selection
        const niktoEnabled = document.getElementById('nikto-enabled')?.checked || false;
        const gobusterEnabled = document.getElementById('gobuster-enabled')?.checked || false;

        if (gobusterEnabled && !niktoEnabled) {
            // Gobuster ONLY Mode
            if (standardGrid) standardGrid.style.display = 'none';
            if (gobusterGrid) gobusterGrid.style.display = 'grid';
            console.log("SWITCH: Gobuster Only Mode");
        } else {
            // Standard / Mixed Mode
            if (standardGrid) standardGrid.style.display = 'grid';
            if (gobusterGrid) gobusterGrid.style.display = 'none';
            // Re-init Master Path if in Standard Mode
            // Logic moved to initialization
        }
    }

    // Attach listeners to Checkboxes to switch UI immediately (for preview/testing)
    document.getElementById('nikto-enabled')?.addEventListener('change', switchWebScanAiMode);
    document.getElementById('gobuster-enabled')?.addEventListener('change', switchWebScanAiMode);

    // Initial check
    switchWebScanAiMode();

    // Gobuster Status Click Handlers
    const statusBtns = document.querySelectorAll('.status-btn');
    statusBtns.forEach(btn => {
        btn.addEventListener('click', function () {
            // Remove active from all
            statusBtns.forEach(b => b.classList.remove('active'));
            // Add active to clicked
            this.classList.add('active');

            // Update Header
            const subHeader = document.getElementById('gobusterStatusHeader');
            if (subHeader) subHeader.textContent = `Status Code: ${this.textContent}`;

            // In a real app, we would filter the table here.
        });
    });



    // Manual AI Analysis Trigger
    const aiBtn = document.getElementById('webStartAiBtn');
    if (aiBtn) {
        aiBtn.addEventListener('click', async () => {
            // Use currentWebScanId for Web Scans!
            if (!currentWebScanId) {
                alert("Önce bir tarama seçiniz veya başlatınız.");
                return;
            }

            aiBtn.disabled = true;
            aiBtn.innerHTML = '<span class="ai-icon">⏳</span> ANALİZ EDİLİYOR...';

            try {
                const response = await fetch(`/api/webscan/analyze/${currentWebScanId}`, {
                    method: 'POST'
                });

                const data = await response.json();

                console.log("AI Analysis Response:", data);

                if (data.success && data.ai_analysis) {
                    // Log the structure to help debug
                    console.log("Master Summary:", data.ai_analysis.master_summary);
                    console.log("Master Steps:", data.ai_analysis.master_steps);
                    console.log("Paths:", data.ai_analysis.paths);
                    console.log("General:", data.ai_analysis.general);

                    // Open the AI panel if not already open
                    const aiPanel = document.getElementById('webAiAnalysisPanel');
                    const toggleBtn = document.getElementById('webAiToggleBtn');
                    if (aiPanel && !aiPanel.classList.contains('open') && toggleBtn) {
                        toggleBtn.click();
                    }

                    // Display the results in the UI
                    displayWebAiAnalysis(data.ai_analysis);
                    alert("AI Analizi Tamamlandı!");

                } else {
                    console.error("AI Analysis failed:", data);
                    alert('Analiz hatası: ' + (data.error || 'Bilinmeyen hata'));
                }
            } catch (error) {
                console.error("AI Trigger Error:", error);
                alert('Bağlantı hatası');
            } finally {
                aiBtn.disabled = false;
                aiBtn.innerHTML = '<span class="ai-icon">✨</span> ANALİZ ET';
            }
        });
    }

}); // End DOMContentLoaded

// Display Web Scan AI Analysis Results
function displayWebAiAnalysis(aiData) {
    console.log("Displaying AI Analysis:", aiData);

    // --- NAVIGATION SETUP ---

    // 1. Setup Master Path Button
    const masterBtn = document.querySelector('.path-master-btn');
    if (masterBtn) {
        masterBtn.onclick = (e) => {
            document.querySelectorAll('.path-btn').forEach(b => b.classList.remove('path-selected'));
            masterBtn.classList.add('path-selected');
            displayMasterView(aiData);
        };
    }

    // 2. Setup General Button
    const generalBtn = document.querySelector('.path-general-btn');
    if (generalBtn && aiData.general) {
        // Update Risk
        const riskSpan = generalBtn.querySelector('.path-risk');
        if (riskSpan) riskSpan.textContent = `(${aiData.general.avg_risk.toFixed(1)})`;

        generalBtn.onclick = () => {
            document.querySelectorAll('.path-btn').forEach(b => b.classList.remove('path-selected'));
            generalBtn.classList.add('path-selected');
            displayGeneralView(aiData.general);
        };
    }

    // 3. Setup Dynamic Path Buttons
    const dynamicPaths = document.getElementById('webDynamicPaths');
    if (dynamicPaths && aiData.paths) {
        dynamicPaths.innerHTML = '';

        Object.entries(aiData.paths).forEach(([path, pathData]) => {
            // Filter: Hide paths with NO vulnerabilities AND 0 risk
            if ((!pathData.vulnerabilities || pathData.vulnerabilities.length === 0) && pathData.avg_risk === 0) {
                return;
            }

            const riskClass = getRiskClass(pathData.avg_risk);
            const button = document.createElement('button');
            button.className = `path-btn path-${riskClass}-btn`;

            button.innerHTML = `
                <span class="path-text">${path}</span>
                <span class="path-risk">(${pathData.avg_risk.toFixed(1)})</span>
            `;

            button.addEventListener('click', () => {
                document.querySelectorAll('.path-btn').forEach(b => b.classList.remove('path-selected'));
                button.classList.add('path-selected');
                displayPathVulnerabilities(path, pathData);
            });
            dynamicPaths.appendChild(button);
        });
    }

    // Initial State: Show Master Path
    if (masterBtn) masterBtn.click();

    // Check if we need to populate Gobuster Grid (If active)
    const gobusterGrid = document.getElementById('webGobusterGrid');
    if (gobusterGrid && getComputedStyle(gobusterGrid).display !== 'none') {
        populateGobusterGrid(aiData);
    }
}

// Populate Gobuster-Only Grid
function populateGobusterGrid(aiData) {
    console.log("Populating Gobuster Grid...", aiData);

    const paths = aiData.paths || {};
    // Group by Status
    const statusGroups = {};

    Object.entries(paths).forEach(([path, data]) => {
        const code = data.status || 0;
        if (!statusGroups[code]) statusGroups[code] = [];
        statusGroups[code].push({ path, ...data });
    });

    // 1. Polulate Sidebar (Status Codes)
    const statusList = document.querySelector('.status-list');
    if (statusList) {
        statusList.innerHTML = '';
        const sortedCodes = Object.keys(statusGroups).sort((a, b) => parseInt(a) - parseInt(b));

        sortedCodes.forEach((code, index) => {
            const btn = document.createElement('button');
            btn.className = `status-btn status-${code}`;
            if (index === 0) btn.classList.add('active'); // Select first

            // Map code to text (Simple mapping)
            let statusText = "Unknown";
            if (code == 200) statusText = "OK";
            if (code == 301) statusText = "Redirect";
            if (code == 302) statusText = "Found";
            if (code == 401) statusText = "Unauthorized";
            if (code == 403) statusText = "Forbidden";
            if (code == 404) statusText = "Not Found";
            if (code == 500) statusText = "Server Error";
            if (code == 502) statusText = "Bad Gateway";

            btn.textContent = `${code} ${statusText}`;

            btn.onclick = () => {
                document.querySelectorAll('.status-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                displayGobusterPaths(code, statusGroups[code], statusText);
            };

            statusList.appendChild(btn);
        });

        // Initial Trigger
        if (sortedCodes.length > 0) {
            const firstCode = sortedCodes[0];
            let firstText = "OK"; // Default hack
            if (firstCode == 403) firstText = "Forbidden"; // etc... (simplified)
            // Better: reused logic
            document.querySelector(`.status-btn.status-${firstCode}`).click();
        }
    }
}

function displayGobusterPaths(code, pathsList, statusText) {
    // Update Header
    const subHeader = document.getElementById('gobusterStatusHeader');
    if (subHeader) subHeader.textContent = `Status Code: ${code} ${statusText}`;

    // Populate Table
    const tbody = document.querySelector('.gobuster-table tbody');
    if (tbody) {
        tbody.innerHTML = '';
        pathsList.forEach((item, index) => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${item.path}</td><td>${item.type}</td>`;
            row.style.cursor = 'pointer';

            if (index === 0) {
                row.style.backgroundColor = 'rgba(255,255,255,0.1)';
                displayGobusterFindings(item); // Show first by default
            }

            row.onclick = () => {
                // reset styles
                Array.from(tbody.children).forEach(r => r.style.backgroundColor = 'transparent');
                row.style.backgroundColor = 'rgba(255,255,255,0.1)';
                displayGobusterFindings(item);
            };

            tbody.appendChild(row);
        });
    }
}

function displayGobusterFindings(pathItem) {
    const findingsCol = document.querySelector('.gobuster-findings-col');
    if (!findingsCol) return;

    // Clear previous
    findingsCol.innerHTML = '';

    // Title
    const title = document.createElement('h4');
    title.style.color = '#60A5FA';
    title.style.marginBottom = '15px';
    title.style.textAlign = 'center';
    title.textContent = 'Potansiyel açıklar ve bulgular';
    findingsCol.appendChild(title);

    // Path Info
    const info = document.createElement('div');
    info.style.marginBottom = '20px';
    info.style.color = '#E2E8F0';
    info.style.textAlign = 'center';
    info.innerHTML = `<strong>${pathItem.path}</strong> (${pathItem.type})`;
    findingsCol.appendChild(info);

    // Vulns / Findings
    if (pathItem.vulnerabilities && pathItem.vulnerabilities.length > 0) {
        const ul = document.createElement('ul');
        ul.style.listStyle = 'none';
        ul.style.padding = '0';

        pathItem.vulnerabilities.forEach(v => {
            const li = document.createElement('li');
            li.style.marginBottom = '10px';
            li.style.color = '#CCD6F6';
            li.style.fontSize = '0.95em';
            li.style.fontStyle = 'italic';
            li.innerHTML = `<span style="color:${getRiskColor(v.risk)}">●</span> ${v.name}: ${v.desc}`;
            ul.appendChild(li);
        });
        findingsCol.appendChild(ul);
    } else {
        const p = document.createElement('p');
        p.style.color = '#888';
        p.textContent = "Bu path için otomatik bir bulgu yok.";
        p.style.textAlign = 'center';
        findingsCol.appendChild(p);
    }
}

// Helper to reset grid columns
function resetAiGrid() {
    // Column 2 (Vulns) - reset and SHOW by default
    const col2 = document.querySelector('.web-ai-vulns');
    if (col2) col2.style.display = 'block';

    const vulnsHeader = document.getElementById('webVulnsHeader');
    const vulnTableContainer = document.querySelector('.web-ai-vulns .table-container');
    if (vulnsHeader) { vulnsHeader.textContent = ""; vulnsHeader.style.color = "#CCD6F6"; }
    if (vulnTableContainer) vulnTableContainer.innerHTML = "";

    // Column 3 (Attack) - reset and SHOW by default
    const col3 = document.querySelector('.web-ai-attack');
    if (col3) col3.style.display = 'block';

    const attackHeader = document.querySelector('.web-ai-attack-header');
    const attackBody = document.getElementById('webAttackBody');
    if (attackHeader) { attackHeader.textContent = ""; attackHeader.style.color = "#CCD6F6"; }
    if (attackBody) attackBody.innerHTML = "";

    // Column 4 (Recommendations) - reset and SHOW by default
    const col4 = document.querySelector('.web-ai-recommendations');
    if (col4) col4.style.display = 'block';

    const recsHeader = document.querySelector('.web-ai-recommendations-header');
    const recsBody = document.getElementById('webRecommendationsBody');
    if (recsHeader) { recsHeader.textContent = ""; recsHeader.style.color = "#CCD6F6"; }
    if (recsBody) recsBody.innerHTML = "";
}

function displayMasterView(aiData) {
    resetAiGrid();

    // DEBUG: Log what AI returned
    console.log("=== MASTER PATH DEBUG ===");
    console.log("master_steps:", aiData.master_steps);
    console.log("master_recommendations:", aiData.master_recommendations);
    console.log("========================");

    // --- MASTER VIEW LAYOUT ---
    // Col 2: Table -> HIDE (Not needed for Master Path)
    // Col 3: Attack Path -> BLUE PANEL
    // Col 4: Recommendations -> GREEN PANEL

    // 1. Hide Column 2 (Vulns Table)
    const col2 = document.querySelector('.web-ai-vulns');
    if (col2) col2.style.display = 'none';

    // 2. Col 3: Attack Path (Blue)
    const attackHeader = document.querySelector('.web-ai-attack-header');
    const attackBody = document.getElementById('webAttackBody');

    if (attackHeader) {
        attackHeader.textContent = "Saldırı Yolları / Kill Chain";
        attackHeader.style.color = "#60A5FA"; // Blue
    }

    if (attackBody && aiData.master_steps) {
        let html = `
            <div style="padding: 10px; color: #CCD6F6; line-height: 1.6;">
                <div style="margin-bottom: 20px; background: rgba(59, 130, 246, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #60A5FA;">
                     <h4 style="color: #60A5FA; margin-bottom: 8px; font-weight:600;">🛡️ Saldırı Özeti</h4>
                    ${aiData.master_summary || "Özet bulunamadı."}
                </div>
                <h4 style="color: #60A5FA; margin: 15px 0 10px 0;">Saldırı Adımları</h4>
                <ol class="attack-steps" style="padding-left: 20px; color: #E2E8F0;">
        `;
        aiData.master_steps.forEach(step => {
            html += `<li style="margin-bottom: 12px;">${step}<div style="margin-top:4px; height:1px; background:rgba(255,255,255,0.05);"></div></li>`;
        });
        html += `   </ol></div>`;
        attackBody.innerHTML = html;
    }

    // 3. Col 4: Recommendations (Green)
    const recsHeader = document.querySelector('.web-ai-recommendations-header');
    const recsBody = document.getElementById('webRecommendationsBody');

    if (recsHeader) {
        recsHeader.textContent = "Önerilen Düzeltme Adımları";
        recsHeader.style.color = "#34D399"; // Green
    }

    if (recsBody) {
        if (aiData.master_recommendations && aiData.master_recommendations.length > 0) {
            let html = '<div style="padding: 10px;">';
            html += '<div style="margin-bottom:15px; color:#34D399; font-size:0.9em;">✅ Bu senaryo için uygulanması gereken kök çözümler:</div>';
            html += '<ul class="recommendations-list">';
            aiData.master_recommendations.forEach(rec => {
                html += `<li style="margin-bottom: 12px; color: #E2E8F0; display:flex; gap:8px;"><span style="color:#34D399;">✔</span> <span>${rec}</span></li>`;
            });
            html += '</ul></div>';
            recsBody.innerHTML = html;
        } else {
            recsBody.innerHTML = '<div style="padding: 20px; color: #888;">Bu senaryo için özel öneri bulunamadı.</div>';
        }
    }
}

function displayGeneralView(generalData) {
    resetAiGrid();

    // Col 2: Findings Table -> VISIBLE
    // Col 3: Attack Panel -> HIDE (Not applicable for General)
    // Col 4: Recommendations -> GREEN PANEL

    // 1. Col 2: Findings
    const vulnsHeader = document.getElementById('webVulnsHeader');
    if (vulnsHeader) vulnsHeader.textContent = "SUNUCU GENELİ ZAFİYETLER";

    const vulnTableContainer = document.querySelector('.web-ai-vulns .table-container');
    if (vulnTableContainer) {
        vulnTableContainer.innerHTML = `
            <table class="vulns-table" id="webGeneralVulnsTable">
                <thead><tr><th style="padding: 12px;">Bulgu</th><th style="width: 60px;">Risk</th></tr></thead>
                <tbody id="webGeneralVulnsTableBody"></tbody>
            </table>
        `;
        const tbody = document.getElementById('webGeneralVulnsTableBody');
        if (generalData.findings) {
            generalData.findings.forEach(vuln => {
                const row = document.createElement('tr');
                row.className = 'vuln-row';
                row.innerHTML = `<td style="padding: 12px;">${vuln.name}</td><td style="text-align: center; color: ${getRiskColor(vuln.risk)};">${vuln.risk.toFixed(1)}</td>`;
                tbody.appendChild(row);
            });
        }
    }

    // 2. Hide Col 3 (Blue Attack Panel)
    const col3 = document.querySelector('.web-ai-attack');
    if (col3) col3.style.display = 'none';

    // 3. Col 4: General Recommendations (Green)
    const recsHeader = document.querySelector('.web-ai-recommendations-header');
    const recsBody = document.getElementById('webRecommendationsBody');

    if (recsHeader) {
        recsHeader.textContent = "Sistem Genelindeki Açıklar İçin İyileştirmeler";
        recsHeader.style.color = "#34D399";
    }

    if (recsBody && generalData.recommendations) {
        let html = '<ul style="padding: 20px;">';
        generalData.recommendations.forEach(rec => html += `<li style="margin-bottom:10px; color:#E2E8F0;">🛡️ ${rec}</li>`);
        html += '</ul>';
        recsBody.innerHTML = html;
    }
}

function displayPathVulnerabilities(path, pathData) {
    resetAiGrid();
    console.log("Displaying vulnerabilities for:", path, pathData);

    // --- PATH VIEW LAYOUT ---
    // Col 2: Vuln Table -> VISIBLE
    // Col 3: Attack Scenario -> BLUE PANEL
    // Col 4: Recommendations -> GREEN PANEL

    // 1. Col 2: Vulnerability Table
    const vulnsHeader = document.getElementById('webVulnsHeader');
    if (vulnsHeader) {
        vulnsHeader.textContent = `${path} (Risk: ${pathData.avg_risk.toFixed(1)})`;
    }
    const vulnTableContainer = document.querySelector('.web-ai-vulns .table-container');
    if (vulnTableContainer) {
        vulnTableContainer.innerHTML = `
            <table class="vulns-table" id="webVulnsTable">
                <thead><tr><th style="padding: 12px;">Açık</th><th style="width: 60px;">Risk</th></tr></thead>
                <tbody id="webVulnsTableBody"></tbody>
            </table>
        `;
        const tbody = document.getElementById('webVulnsTableBody');
        if (pathData.vulnerabilities) {
            pathData.vulnerabilities.forEach(vuln => {
                const row = document.createElement('tr');
                row.className = 'vuln-row';
                row.innerHTML = `<td style="padding:12px;">${vuln.name}</td><td style="color:${getRiskColor(vuln.risk)}; text-align:center;">${vuln.risk.toFixed(1)}</td>`;
                tbody.appendChild(row);
            });
        }
    }

    // 2. Col 3: Attack Scenario (Blue)
    const attackHeader = document.querySelector('.web-ai-attack-header');
    const attackBody = document.getElementById('webAttackBody');

    if (attackHeader) {
        attackHeader.textContent = "Saldırı Yolları / Kill Chain";
        attackHeader.style.color = "#60A5FA";
    }

    if (attackBody) {
        if (pathData.path_attack_scenario && pathData.path_attack_scenario.length > 0) {
            let html = `
                <div style="padding: 20px;">
                    <div style="background: rgba(59, 130, 246, 0.1); padding: 15px; border-radius: 8px; border-left: 3px solid #60A5FA; margin-bottom:15px;">
                        <span style="color:#60A5FA;">⚔️ En Kritik Açık İçin Saldırı Adımları:</span>
                    </div>
                    <ol class="attack-steps" style="color: #E2E8F0; padding-left:20px;">
            `;
            pathData.path_attack_scenario.forEach(step => {
                html += `<li style="margin-bottom: 12px;">${step}</li>`;
            });
            html += '</ol></div>';
            attackBody.innerHTML = html;
        } else {
            attackBody.innerHTML = '<div style="padding: 20px; color: #888;">Saldırı senaryosu yok.</div>';
        }
    }

    // 3. Col 4: Recommendations (Green)
    const recsHeader = document.querySelector('.web-ai-recommendations-header');
    const recsBody = document.getElementById('webRecommendationsBody');

    if (recsHeader) {
        recsHeader.textContent = "Önerilen Düzeltme Adımları";
        recsHeader.style.color = "#34D399";
    }

    if (recsBody) {
        if (pathData.path_recommendations && pathData.path_recommendations.length > 0) {
            let html = '<div style="padding: 20px;">';
            html += '<ul class="recommendations-list">';
            pathData.path_recommendations.forEach(rec => {
                html += `<li style="margin-bottom: 12px; color: #E2E8F0; display:flex; gap:8px;"><span style="color:#34D399;">✔</span> <span>${rec}</span></li>`;
            });
            html += '</ul></div>';
            recsBody.innerHTML = html;
        } else {
            recsBody.innerHTML = '<div style="padding: 20px; color: #888;">Öneri bulunamadı.</div>';
        }
    }
}

function displayVulnDetails(vuln) {
    const attackHeader = document.querySelector('.web-ai-attack-header');
    if (attackHeader) attackHeader.textContent = "Zafiyet Detayı & PoC";

    const attackBody = document.getElementById('webAttackBody');
    if (attackBody) {
        attackBody.innerHTML = `
            <div style="color: #CCD6F6; line-height: 1.6; padding: 15px;">
                <div style="font-weight: 700; margin-bottom: 12px; color: #FFFFFF; font-size: 16px; border-bottom: 1px solid #333; padding-bottom:10px;">${vuln.name}</div>
                <div style="margin-bottom: 16px;">
                    Risk Puanı: <span style="background: ${getRiskColor(vuln.risk)}20; color: ${getRiskColor(vuln.risk)}; padding: 2px 8px; border-radius: 4px; font-weight: bold;">${vuln.risk.toFixed(1)}</span>
                </div>
                <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.05);">
                    <h5 style="color: #9CA3AF; margin-bottom: 8px; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">Açıklama ve Sömürü (PoC)</h5>
                    <div style="font-size: 14px; opacity: 0.9;">${vuln.desc}</div>
                </div>
            </div>
        `;
    }
}

function getRiskClass(risk) {
    if (risk >= 9.0) return 'critical';
    if (risk >= 7.0) return 'high';
    if (risk >= 4.0) return 'medium';
    return 'low';
}

function getRiskColor(risk) {
    if (risk >= 9.0) return '#EF4444';
    if (risk >= 7.0) return '#F97316';
    if (risk >= 4.0) return '#EAB308';
    return '#3B82F6';
}

