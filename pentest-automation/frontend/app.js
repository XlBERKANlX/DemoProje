// Radio Button Logic - Host Discovery vs Port Selection
const scanTypeRadios = document.querySelectorAll('input[name="scan-type"]');
const portSelectionRadios = document.querySelectorAll('input[name="port-selection"]');

// Add toggle functionality to radio buttons (click again to deselect)
function makeRadioToggleable(radioButtons) {
    radioButtons.forEach(radio => {
        radio.addEventListener('click', function (e) {
            // If already checked, uncheck it
            if (this.dataset.wasChecked === 'true') {
                this.checked = false;
                this.dataset.wasChecked = 'false';
                // Trigger change event to update dependent states
                this.dispatchEvent(new Event('change'));
            } else {
                // Mark all radios in this group as unchecked
                radioButtons.forEach(r => r.dataset.wasChecked = 'false');
                // Mark this one as checked
                this.dataset.wasChecked = 'true';
            }
        });
    });
}

// Apply toggle functionality to both radio groups
makeRadioToggleable(scanTypeRadios);
makeRadioToggleable(portSelectionRadios);

function updatePortSelectionState() {
    const hostDiscoveryRadio = document.querySelector('input[name="scan-type"][value="host"]');
    const hostDiscoverySelected = hostDiscoveryRadio?.checked;

    portSelectionRadios.forEach(radio => {
        if (hostDiscoverySelected) {
            // Disable port selection when Host Discovery is selected
            radio.disabled = true;
            radio.checked = false;
            radio.dataset.wasChecked = 'false';
            radio.parentElement.style.opacity = '0.5';
            radio.parentElement.style.cursor = 'not-allowed';
        } else {
            // Enable port selection for other scan types
            radio.disabled = false;
            radio.parentElement.style.opacity = '1';
            radio.parentElement.style.cursor = 'pointer';
        }
    });
}

// When port selection is made, auto-deselect host discovery
portSelectionRadios.forEach(radio => {
    radio.addEventListener('change', () => {
        if (radio.checked) {
            const hostDiscoveryRadio = document.querySelector('input[name="scan-type"][value="host"]');
            if (hostDiscoveryRadio && hostDiscoveryRadio.checked) {
                hostDiscoveryRadio.checked = false;
                hostDiscoveryRadio.dataset.wasChecked = 'false';
                updatePortSelectionState();
            }
        }
    });
});

// Listen to scan type changes
scanTypeRadios.forEach(radio => {
    radio.addEventListener('change', updatePortSelectionState);
});

// Initialize on page load - port options enabled by default
updatePortSelectionState();

// AI Analysis Panel Toggle
const aiToggleBtn = document.getElementById('aiToggleBtn');
const aiAnalysisPanel = document.getElementById('aiAnalysisPanel');

aiToggleBtn.addEventListener('click', () => {
    aiAnalysisPanel.classList.toggle('open');
    aiToggleBtn.classList.toggle('active');
});

// Device Selection
const deviceItems = document.querySelectorAll('.device-item');
deviceItems.forEach(device => {
    device.addEventListener('click', () => {
        // Remove selected class from all devices
        deviceItems.forEach(d => d.classList.remove('device-selected'));
        // Add selected class to clicked device
        device.classList.add('device-selected');

        // Update technical details (placeholder - will be dynamic with backend)
        const deviceName = device.querySelector('.device-name').textContent;
        document.querySelector('.details-header').textContent = `Teknik Detaylar: ${deviceName}`;
    });
});

// Vulnerability Item Selection
const vulnItems = document.querySelectorAll('.vuln-item');
const cveSeverityCard = document.getElementById('cveSeverityCard');

vulnItems.forEach(item => {
    item.addEventListener('click', () => {
        // Remove selected class from all items
        vulnItems.forEach(v => v.classList.remove('vuln-selected'));
        // Add selected class to clicked item
        item.classList.add('vuln-selected');

        // Update CVE details (placeholder - will be dynamic with backend)
        const vulnText = item.textContent.trim();
        document.querySelector('.cve-header').textContent = vulnText;

        // Update CVE severity card color based on vulnerability type
        if (cveSeverityCard) {
            // Remove all severity classes
            cveSeverityCard.classList.remove('cve-card-critical', 'cve-card-medium', 'cve-card-low');

            // Add appropriate class based on selected vulnerability
            if (item.classList.contains('vuln-critical')) {
                cveSeverityCard.classList.add('cve-card-critical');
            } else if (item.classList.contains('vuln-medium')) {
                cveSeverityCard.classList.add('cve-card-medium');
            } else if (item.classList.contains('vuln-low')) {
                cveSeverityCard.classList.add('cve-card-low');
            } else {
                // Default to critical for general overview
                cveSeverityCard.classList.add('cve-card-critical');
            }
        }
    });
});

// Filter Buttons
const filterBtns = document.querySelectorAll('.filter-btn');
filterBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        // Remove active class from all filters
        filterBtns.forEach(b => b.classList.remove('filter-active'));
        // Add active class to clicked filter
        btn.classList.add('filter-active');

        // Filter logic will be implemented with backend data
        console.log('Filter clicked:', btn.textContent);
    });
});

// Start Scan Button - BACKEND INTEGRATION
const startScanBtn = document.querySelector('.btn-start-scan');
const devicesList = document.querySelector('.devices-list');
let currentScanId = null;
let pollInterval = null;
let isScanning = false;

startScanBtn.addEventListener('click', async () => {
    // If scanning, cancel the scan
    if (isScanning) {
        await cancelScan();
        return;
    }

    // Collect scan parameters
    const targets = document.querySelector('.input-field').value;

    if (!targets) {
        alert('L√ºtfen tarama hedefi girin (√∂rn: 10.0.2.5 veya 10.0.2.0/24)');
        return;
    }

    const scanParams = {
        targets: targets,
        scanType: document.querySelector('input[name="scan-type"]:checked')?.value || 'host',
        portSelection: document.querySelector('input[name="port-selection"]:checked')?.value,
        synScan: document.querySelector('input[name="syn-scan"]')?.checked || false,
        versionScan: document.querySelector('input[name="version-scan"]')?.checked || false,
        osScan: document.querySelector('input[name="os-scan"]')?.checked || false,
        speed: document.querySelector('.select-field')?.value || 'normal'
    };

    console.log('Starting scan with parameters:', scanParams);

    try {
        // Change button to cancel mode
        isScanning = true;
        startScanBtn.classList.add('scanning');
        startScanBtn.textContent = 'ƒ∞ptal Et';

        // Clear previous results
        devicesList.innerHTML = '<div style="color: #CCD6F6; padding: 20px;">Tarama ba≈ülatƒ±lƒ±yor...</div>';

        // Start scan
        const response = await fetch('/api/scan/start', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(scanParams)
        });

        const data = await response.json();

        if (data.success) {
            currentScanId = data.scan_id;
            devicesList.innerHTML = '<div style="color: #CCD6F6; padding: 20px;">‚è≥ Tarama devam ediyor...</div>';

            // Start polling for results
            pollScanStatus(currentScanId);
        } else {
            throw new Error(data.error || 'Tarama ba≈ülatƒ±lamadƒ±');
        }
    } catch (error) {
        console.error('Scan error:', error);
        alert(`Hata: ${error.message}`);
        resetScanButton();
        devicesList.innerHTML = '<div style="color: #F50000; padding: 20px;">‚ùå Tarama ba≈ülatƒ±lamadƒ±: ' + error.message + '</div>';
    }
});

// Cancel scan function
async function cancelScan() {
    if (!currentScanId) return;

    try {
        const response = await fetch(`/api/scan/cancel/${currentScanId}`, {
            method: 'POST'
        });

        const data = await response.json();

        if (data.success) {
            devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">‚ö†Ô∏è Tarama iptal edildi</div>';
        } else {
            alert(`ƒ∞ptal hatasƒ±: ${data.error}`);
        }
    } catch (error) {
        console.error('Cancel error:', error);
        alert(`ƒ∞ptal hatasƒ±: ${error.message}`);
    } finally {
        resetScanButton();
        if (pollInterval) {
            clearInterval(pollInterval);
        }
    }
}

// Reset scan button to initial state
function resetScanButton() {
    isScanning = false;
    startScanBtn.classList.remove('scanning');
    startScanBtn.textContent = 'Taramayƒ± Ba≈ülat';
    startScanBtn.disabled = false;
}

// Poll scan status and results
function pollScanStatus(scanId) {
    // Clear any existing interval
    if (pollInterval) {
        clearInterval(pollInterval);
    }

    // Poll every 2 seconds
    pollInterval = setInterval(async () => {
        try {
            const response = await fetch(`/api/scan/status/${scanId}`);
            const data = await response.json();

            if (data.success) {
                const status = data.status;

                if (status === 'completed') {
                    // Scan completed, get results
                    clearInterval(pollInterval);
                    await loadScanResults(scanId);
                    resetScanButton();
                } else if (status === 'failed') {
                    // Scan failed
                    clearInterval(pollInterval);
                    devicesList.innerHTML = `<div style="color: #F50000; padding: 20px;">‚ùå Tarama ba≈üarƒ±sƒ±z: ${data.error}</div>`;
                    resetScanButton();
                } else if (status === 'cancelled') {
                    // Scan cancelled
                    clearInterval(pollInterval);
                    devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">‚ö†Ô∏è Tarama iptal edildi</div>';
                    resetScanButton();
                } else {
                    // Still running - show incremental results
                    const devicesFound = data.devices_found || 0;

                    // Try to get partial results
                    try {
                        const resultsResponse = await fetch(`/api/scan/results/${scanId}`);
                        const resultsData = await resultsResponse.json();

                        if (resultsData.success && resultsData.devices && resultsData.devices.length > 0) {
                            // Display partial results
                            displayDevicesIncremental(resultsData.devices, true);
                        } else {
                            devicesList.innerHTML = `<div style="color: #CCD6F6; padding: 20px;">‚è≥ Tarama devam ediyor... (${devicesFound} cihaz bulundu)</div>`;
                        }
                    } catch (e) {
                        devicesList.innerHTML = `<div style="color: #CCD6F6; padding: 20px;">‚è≥ Tarama devam ediyor... (${devicesFound} cihaz bulundu)</div>`;
                    }
                }
            }
        } catch (error) {
            console.error('Status poll error:', error);
        }
    }, 500);  // Poll every 500ms for faster updates
}

// Load and display scan results
async function loadScanResults(scanId) {
    try {
        const response = await fetch(`/api/scan/results/${scanId}`);
        const data = await response.json();

        if (data.success && data.devices && data.devices.length > 0) {
            displayDevices(data.devices);
        } else {
            devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">‚ö†Ô∏è Tarama tamamlandƒ±, ancak cihaz bulunamadƒ±.</div>';
        }
    } catch (error) {
        console.error('Results load error:', error);
        devicesList.innerHTML = '<div style="color: #F50000; padding: 20px;">‚ùå Sonu√ßlar y√ºklenemedi</div>';
    }
}

// Display devices in the UI
function displayDevices(devices) {
    devicesList.innerHTML = '';

    devices.forEach((device, index) => {
        const deviceItem = document.createElement('div');
        deviceItem.className = 'device-item';
        if (index === 0) deviceItem.classList.add('device-selected');

        // Get device icon
        const iconInfo = getDeviceIcon(device.hostname || device.ip, device.os || '');

        // Count vulnerabilities (placeholder for now)
        const vulnCounts = device.vulnerabilities || { critical: 0, medium: 0, low: 0 };
        const portCount = device.ports ? device.ports.length : 0;

        deviceItem.innerHTML = `
            <div class="device-icon">
                <img src="${iconInfo.src}" alt="${iconInfo.alt}" class="device-icon-img" 
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
                <span class="device-icon-fallback" style="display:none;">${iconInfo.fallback}</span>
            </div>
            <div class="device-info">
                <div class="device-name">${device.ip} (${device.hostname})</div>
                <div class="device-stats">
                    ${vulnCounts.critical > 0 ? `<span class="stat-critical">üî• Kritik: ${vulnCounts.critical}</span>` : ''}
                    ${vulnCounts.medium > 0 ? `<span class="stat-medium">üü† Orta: ${vulnCounts.medium}</span>` : ''}
                    ${vulnCounts.low > 0 ? `<span class="stat-low">üü° D√º≈ü√ºk: ${vulnCounts.low}</span>` : ''}
                    ${portCount > 0 ? `<span class="stat-safe">üü¢ Port: ${portCount}</span>` : '<span class="stat-safe">üü¢ Aktif</span>'}
                </div>
            </div>
            <div class="device-arrow">></div>
        `;

        // Store device data
        deviceItem.dataset.deviceData = JSON.stringify(device);

        // Add click handler
        deviceItem.addEventListener('click', () => {
            document.querySelectorAll('.device-item').forEach(d => d.classList.remove('device-selected'));
            deviceItem.classList.add('device-selected');
            displayTechnicalDetails(device);
        });

        devicesList.appendChild(deviceItem);
    });

    // Display first device details
    if (devices.length > 0) {
        displayTechnicalDetails(devices[0]);
    }
}

// Display technical details for selected device
function displayTechnicalDetails(device) {
    const detailsHeader = document.querySelector('.details-header');
    const detailsTerminal = document.querySelector('.details-terminal');

    detailsHeader.textContent = `Teknik Detaylar: ${device.ip} (${device.hostname})`;

    if (device.ports && device.ports.length > 0) {
        let html = `
            <div class="terminal-row">
                <div class="terminal-label">PORT</div>
                <div class="terminal-label">STATE</div>
                <div class="terminal-label">SERVICE</div>
                <div class="terminal-label">VERSION</div>
            </div>
        `;

        device.ports.forEach(port => {
            html += `
                <div class="terminal-row">
                    <div class="terminal-value">${port.port}/${port.protocol}</div>
                    <div class="terminal-value" style="color: #38C271;">${port.state}</div>
                    <div class="terminal-value" style="color: #63B3ED;">${port.service || 'unknown'}</div>
                    <div class="terminal-value">${port.version || port.product || '-'}</div>
                </div>
            `;
        });

        detailsTerminal.innerHTML = html;
    } else {
        detailsTerminal.innerHTML = `
            <div class="terminal-row">
                <div class="terminal-label">PORT</div>
                <div class="terminal-label">STATE</div>
                <div class="terminal-label">SERVICE</div>
                <div class="terminal-label">VERSION</div>
            </div>
            <div style="color: #CCD6F6; padding: 20px;">A√ßƒ±k port bulunamadƒ± (Host Discovery modu)</div>
        `;
    }
}

// Auto Fill Button
const autoFillBtn = document.querySelector('.btn-auto-fill');
autoFillBtn.addEventListener('click', () => {
    // Auto-fill with local network range (placeholder)
    document.querySelector('.input-field').value = '10.0.2.0/24';
    console.log('Auto-filled target range');
});

// Search Input
const searchInput = document.querySelector('.search-input');
searchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();

    document.querySelectorAll('.device-item').forEach(device => {
        const deviceName = device.querySelector('.device-name').textContent.toLowerCase();
        if (deviceName.includes(searchTerm)) {
            device.style.display = 'flex';
        } else {
            device.style.display = 'none';
        }
    });
});

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    console.log('Pentest Otomasyon Motoru initialized');
    updatePortSelectionState(); // Ensure correct initial state
});
