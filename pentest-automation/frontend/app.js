// Radio Button Logic - Host Discovery vs Port Selection
const scanTypeRadios = document.querySelectorAll('input[name="scan-type"]');
const portSelectionRadios = document.querySelectorAll('input[name="port-selection"]');

// Add toggle functionality to radio buttons (click again to deselect)
function makeRadioToggleable(radioButtons) {
    radioButtons.forEach(radio => {
        radio.addEventListener('click', function (e) {
            // If already checked, uncheck it
            if (this.dataset.wasChecked === 'true') {
                this.checked = false;
                this.dataset.wasChecked = 'false';
                // Trigger change event to update dependent states
                this.dispatchEvent(new Event('change'));
            } else {
                // Mark all radios in this group as unchecked
                radioButtons.forEach(r => r.dataset.wasChecked = 'false');
                // Mark this one as checked
                this.dataset.wasChecked = 'true';
            }
        });
    });
}

// Apply toggle functionality to both radio groups
makeRadioToggleable(scanTypeRadios);
makeRadioToggleable(portSelectionRadios);

function updatePortSelectionState() {
    const hostDiscoveryRadio = document.querySelector('input[name="scan-type"][value="host"]');
    const hostDiscoverySelected = hostDiscoveryRadio?.checked;

    portSelectionRadios.forEach(radio => {
        if (hostDiscoverySelected) {
            // Disable port selection when Host Discovery is selected
            radio.disabled = true;
            radio.checked = false;
            radio.dataset.wasChecked = 'false';
            radio.parentElement.style.opacity = '0.5';
            radio.parentElement.style.cursor = 'not-allowed';
        } else {
            // Enable port selection for other scan types
            radio.disabled = false;
            radio.parentElement.style.opacity = '1';
            radio.parentElement.style.cursor = 'pointer';
        }
    });
}

// When port selection is made, auto-deselect host discovery
portSelectionRadios.forEach(radio => {
    radio.addEventListener('change', () => {
        if (radio.checked) {
            const hostDiscoveryRadio = document.querySelector('input[name="scan-type"][value="host"]');
            if (hostDiscoveryRadio && hostDiscoveryRadio.checked) {
                hostDiscoveryRadio.checked = false;
                hostDiscoveryRadio.dataset.wasChecked = 'false';
                updatePortSelectionState();
            }
        }
    });
});

// Listen to scan type changes
scanTypeRadios.forEach(radio => {
    radio.addEventListener('change', updatePortSelectionState);
});

// Initialize on page load - port options enabled by default
updatePortSelectionState();

// AI Analysis Panel Toggle
const aiToggleBtn = document.getElementById('aiToggleBtn');
const aiAnalysisPanel = document.getElementById('aiAnalysisPanel');

aiToggleBtn.addEventListener('click', () => {
    aiAnalysisPanel.classList.toggle('open');
    aiToggleBtn.classList.toggle('active');
});

// Device Selection
const deviceItems = document.querySelectorAll('.device-item');
deviceItems.forEach(device => {
    device.addEventListener('click', () => {
        // Remove selected class from all devices
        deviceItems.forEach(d => d.classList.remove('device-selected'));
        // Add selected class to clicked device
        device.classList.add('device-selected');

        // Update technical details (placeholder - will be dynamic with backend)
        const deviceName = device.querySelector('.device-name').textContent;
        document.querySelector('.details-header').textContent = `Teknik Detaylar: ${deviceName}`;
    });
});

// Vulnerability Item Selection
const vulnItems = document.querySelectorAll('.vuln-item');
const cveSeverityCard = document.getElementById('cveSeverityCard');

vulnItems.forEach(item => {
    item.addEventListener('click', () => {
        // Remove selected class from all items
        vulnItems.forEach(v => v.classList.remove('vuln-selected'));
        // Add selected class to clicked item
        item.classList.add('vuln-selected');

        // Update CVE details (placeholder - will be dynamic with backend)
        const vulnText = item.textContent.trim();
        document.querySelector('.cve-header').textContent = vulnText;

        // Update CVE severity card color based on vulnerability type
        if (cveSeverityCard) {
            // Remove all severity classes
            cveSeverityCard.classList.remove('cve-card-critical', 'cve-card-medium', 'cve-card-low');

            // Add appropriate class based on selected vulnerability
            if (item.classList.contains('vuln-critical')) {
                cveSeverityCard.classList.add('cve-card-critical');
            } else if (item.classList.contains('vuln-medium')) {
                cveSeverityCard.classList.add('cve-card-medium');
            } else if (item.classList.contains('vuln-low')) {
                cveSeverityCard.classList.add('cve-card-low');
            } else {
                // Default to critical for general overview
                cveSeverityCard.classList.add('cve-card-critical');
            }
        }
    });
});

// Filter Buttons
const filterBtns = document.querySelectorAll('.filter-btn');
filterBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        // Remove active class from all filters
        filterBtns.forEach(b => b.classList.remove('filter-active'));
        // Add active class to clicked filter
        btn.classList.add('filter-active');

        // Filter logic will be implemented with backend data
        console.log('Filter clicked:', btn.textContent);
    });
});

// Start Scan Button - BACKEND INTEGRATION
const startScanBtn = document.querySelector('.btn-start-scan');
const devicesList = document.querySelector('.devices-list');
let currentScanId = null;
let pollInterval = null;
let isScanning = false;

startScanBtn.addEventListener('click', async () => {
    // If scanning, cancel the scan
    if (isScanning) {
        await cancelScan();
        return;
    }

    // Collect scan parameters
    const targets = document.querySelector('.input-field').value;

    if (!targets) {
        alert('L√ºtfen tarama hedefi girin (√∂rn: 10.0.2.5 veya 10.0.2.0/24)');
        return;
    }

    const scanParams = {
        targets: targets,
        scanType: document.querySelector('input[name="scan-type"]:checked')?.value || 'host',
        portSelection: document.querySelector('input[name="port-selection"]:checked')?.value,
        synScan: document.querySelector('input[name="syn-scan"]')?.checked || false,
        versionScan: document.querySelector('input[name="version-scan"]')?.checked || false,
        osScan: document.querySelector('input[name="os-scan"]')?.checked || false,
        speed: document.querySelector('.select-field')?.value || 'normal'
    };

    console.log('Starting scan with parameters:', scanParams);

    try {
        // Change button to cancel mode
        isScanning = true;
        startScanBtn.classList.add('scanning');
        startScanBtn.textContent = 'ƒ∞ptal Et';

        // Clear previous results
        devicesList.innerHTML = '<div style="color: #CCD6F6; padding: 20px;">Tarama ba≈ülatƒ±lƒ±yor...</div>';

        // Start scan
        const response = await fetch('/api/scan/start', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(scanParams)
        });

        const data = await response.json();

        if (data.success) {
            currentScanId = data.scan_id;
            devicesList.innerHTML = '<div style="color: #CCD6F6; padding: 20px;">‚è≥ Tarama devam ediyor...</div>';

            // Start polling for results
            pollScanStatus(currentScanId);
        } else {
            throw new Error(data.error || 'Tarama ba≈ülatƒ±lamadƒ±');
        }
    } catch (error) {
        console.error('Scan error:', error);
        alert(`Hata: ${error.message}`);
        resetScanButton();
        devicesList.innerHTML = '<div style="color: #F50000; padding: 20px;">‚ùå Tarama ba≈ülatƒ±lamadƒ±: ' + error.message + '</div>';
    }
});

// Cancel scan function
async function cancelScan() {
    if (!currentScanId) return;

    try {
        const response = await fetch(`/api/scan/cancel/${currentScanId}`, {
            method: 'POST'
        });

        const data = await response.json();

        if (data.success) {
            devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">‚ö†Ô∏è Tarama iptal edildi</div>';
        } else {
            alert(`ƒ∞ptal hatasƒ±: ${data.error}`);
        }
    } catch (error) {
        console.error('Cancel error:', error);
        alert(`ƒ∞ptal hatasƒ±: ${error.message}`);
    } finally {
        resetScanButton();
        if (pollInterval) {
            clearInterval(pollInterval);
        }
    }
}

// Reset scan button to initial state
function resetScanButton() {
    isScanning = false;
    startScanBtn.classList.remove('scanning');
    startScanBtn.textContent = 'Taramayƒ± Ba≈ülat';
    startScanBtn.disabled = false;
}

// Poll scan status and results
function pollScanStatus(scanId) {
    // Clear any existing interval
    if (pollInterval) {
        clearInterval(pollInterval);
    }

    // Poll every 2 seconds
    pollInterval = setInterval(async () => {
        try {
            const response = await fetch(`/api/scan/status/${scanId}`);
            const data = await response.json();

            if (data.success) {
                const status = data.status;

                if (status === 'completed') {
                    // Scan completed, get results
                    clearInterval(pollInterval);
                    await loadScanResults(scanId);
                    resetScanButton();
                } else if (status === 'failed') {
                    // Scan failed
                    clearInterval(pollInterval);
                    devicesList.innerHTML = `<div style="color: #F50000; padding: 20px;">‚ùå Tarama ba≈üarƒ±sƒ±z: ${data.error}</div>`;
                    resetScanButton();
                } else if (status === 'cancelled') {
                    // Scan cancelled
                    clearInterval(pollInterval);
                    devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">‚ö†Ô∏è Tarama iptal edildi</div>';
                    resetScanButton();
                } else {
                    // Still running - show incremental results
                    const devicesFound = data.devices_found || 0;

                    // Try to get partial results
                    try {
                        const resultsResponse = await fetch(`/api/scan/results/${scanId}`);
                        const resultsData = await resultsResponse.json();

                        if (resultsData.success && resultsData.devices && resultsData.devices.length > 0) {
                            // Display partial results
                            displayDevicesIncremental(resultsData.devices, true);
                        } else {
                            devicesList.innerHTML = `<div style="color: #CCD6F6; padding: 20px;">‚è≥ Tarama devam ediyor... (${devicesFound} cihaz bulundu)</div>`;
                        }
                    } catch (e) {
                        devicesList.innerHTML = `<div style="color: #CCD6F6; padding: 20px;">‚è≥ Tarama devam ediyor... (${devicesFound} cihaz bulundu)</div>`;
                    }
                }
            }
        } catch (error) {
            console.error('Status poll error:', error);
        }
    }, 500);  // Poll every 500ms for faster updates
}

// Load and display scan results
async function loadScanResults(scanId) {
    try {
        const response = await fetch(`/api/scan/results/${scanId}`);
        const data = await response.json();

        if (data.success && data.devices && data.devices.length > 0) {
            displayDevices(data.devices);
        } else {
            devicesList.innerHTML = '<div style="color: #FFE100; padding: 20px;">‚ö†Ô∏è Tarama tamamlandƒ±, ancak cihaz bulunamadƒ±.</div>';
        }
    } catch (error) {
        console.error('Results load error:', error);
        devicesList.innerHTML = '<div style="color: #F50000; padding: 20px;">‚ùå Sonu√ßlar y√ºklenemedi</div>';
    }
}

// Display devices in the UI
function displayDevices(devices) {
    devicesList.innerHTML = '';

    devices.forEach((device, index) => {
        const deviceItem = document.createElement('div');
        deviceItem.className = 'device-item';
        if (index === 0) deviceItem.classList.add('device-selected');

        // Get device icon
        const iconInfo = getDeviceIcon(device.hostname || device.ip, device.os || '');

        // Count vulnerabilities (placeholder for now)
        const vulnCounts = device.vulnerabilities || { critical: 0, medium: 0, low: 0 };
        const portCount = device.ports ? device.ports.length : 0;

        deviceItem.innerHTML = `
            <div class="device-icon">
                <img src="${iconInfo.src}" alt="${iconInfo.alt}" class="device-icon-img" 
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
                <span class="device-icon-fallback" style="display:none;">${iconInfo.fallback}</span>
            </div>
            <div class="device-info">
                <div class="device-name">${device.ip} (${device.hostname})</div>
                <div class="device-stats">
                    ${vulnCounts.critical > 0 ? `<span class="stat-critical">üî• Kritik: ${vulnCounts.critical}</span>` : ''}
                    ${vulnCounts.medium > 0 ? `<span class="stat-medium">üü† Orta: ${vulnCounts.medium}</span>` : ''}
                    ${vulnCounts.low > 0 ? `<span class="stat-low">üü° D√º≈ü√ºk: ${vulnCounts.low}</span>` : ''}
                    ${portCount > 0 ? `<span class="stat-safe">üü¢ Port: ${portCount}</span>` : '<span class="stat-safe">üü¢ Aktif</span>'}
                </div>
            </div>
            <div class="device-arrow">></div>
        `;

        // Store device data
        deviceItem.dataset.deviceData = JSON.stringify(device);

        // Add click handler
        deviceItem.addEventListener('click', () => {
            document.querySelectorAll('.device-item').forEach(d => d.classList.remove('device-selected'));
            deviceItem.classList.add('device-selected');
            displayTechnicalDetails(device);
        });

        devicesList.appendChild(deviceItem);
    });

    // Display first device details
    if (devices.length > 0) {
        displayTechnicalDetails(devices[0]);
    }
}

// Display technical details for selected device
function displayTechnicalDetails(device) {
    const detailsHeader = document.querySelector('.details-header');
    const detailsTerminal = document.querySelector('.details-terminal');

    detailsHeader.textContent = `Teknik Detaylar: ${device.ip} (${device.hostname})`;

    if (device.ports && device.ports.length > 0) {
        let html = `
            <div style="margin-bottom: 20px; display: flex; justify-content: flex-end;">
                <button onclick='analyzeWithAI(${JSON.stringify(device)})' class="btn-ai-analyze" style="
                    background: linear-gradient(90deg, #7928CA, #FF0080);
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    color: white;
                    font-weight: 600;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-family: 'Inter', sans-serif;
                    box-shadow: 0 4px 12px rgba(121, 40, 202, 0.3);
                    transition: transform 0.2s;
                ">
                    ‚ú® AI ile Zafiyet Analizi
                </button>
            </div>
            <div id="ai-analysis-result" style="margin-bottom: 20px; display: none;"></div>
            <div class="terminal-row">
                <div class="terminal-label">PORT</div>
                <div class="terminal-label">STATE</div>
                <div class="terminal-label">SERVICE</div>
                <div class="terminal-label">VERSION</div>
            </div>
        `;

        device.ports.forEach(port => {
            html += `
                <div class="terminal-row">
                    <div class="terminal-value">${port.port}/${port.protocol}</div>
                    <div class="terminal-value" style="color: #38C271;">${port.state}</div>
                    <div class="terminal-value" style="color: #63B3ED;">${port.service || 'unknown'}</div>
                    <div class="terminal-value">${port.version || port.product || '-'}</div>
                </div>
            `;
        });

        detailsTerminal.innerHTML = html;
    } else {
        detailsTerminal.innerHTML = `
            <div style="margin-bottom: 20px; display: flex; justify-content: flex-end;">
                <button onclick='analyzeWithAI(${JSON.stringify(device)})' class="btn-ai-analyze" style="
                    background: linear-gradient(90deg, #7928CA, #FF0080);
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    color: white;
                    font-weight: 600;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-family: 'Inter', sans-serif;
                ">
                    ‚ú® AI ile Zafiyet Analizi
                </button>
            </div>
            <div id="ai-analysis-result" style="margin-bottom: 20px; display: none;"></div>
            <div class="terminal-row">
                <div class="terminal-label">PORT</div>
                <div class="terminal-label">STATE</div>
                <div class="terminal-label">SERVICE</div>
                <div class="terminal-label">VERSION</div>
            </div>
            <div style="color: #CCD6F6; padding: 20px;">A√ßƒ±k port bulunamadƒ± (Host Discovery modu)</div>
        `;
    }
}

// AI Analysis Function
async function analyzeWithAI(device) {
    const resultDiv = document.getElementById('ai-analysis-result');
    const btn = document.querySelector('.btn-ai-analyze');

    // Show loading
    btn.disabled = true;
    btn.innerHTML = '‚è≥ Analiz yapƒ±lƒ±yor...';
    btn.style.opacity = '0.8';

    resultDiv.style.display = 'block';
    resultDiv.innerHTML = `
        <div style="background: rgba(121, 40, 202, 0.1); border: 1px solid #7928CA; border-radius: 8px; padding: 20px;">
            <div style="color: #CCD6F6; text-align: center;">Gemini AI cihazƒ± analiz ediyor, l√ºtfen bekleyin...</div>
        </div>
    `;

    try {
        const response = await fetch('/api/analyze/device', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(device)
        });

        const data = await response.json();

        if (data.success) {
            const analysis = data.analysis;

            // Determine risk color
            let riskColor = '#38C271'; // Low
            if (analysis.risk_score > 7.5) riskColor = '#F50000'; // Critical
            else if (analysis.risk_score > 5) riskColor = '#F59E0B'; // High/Medium
            else if (analysis.risk_score > 2.5) riskColor = '#FFE100'; // Medium/Low

            let vulnsHtml = '';
            if (analysis.vulnerabilities && analysis.vulnerabilities.length > 0) {
                vulnsHtml = '<h4>Tespit Edilen Zafiyetler:</h4>';
                analysis.vulnerabilities.forEach(v => {
                    const severityColor = v.severity.toLowerCase() === 'critical' ? '#F50000' :
                        v.severity.toLowerCase() === 'high' ? '#F59E0B' : '#FFE100';
                    const cvssDisplay = v.cvss_score ?
                        `<span style="color: #63B3ED; font-size: 0.8em; border: 1px solid #63B3ED; padding: 2px 6px; border-radius: 4px; margin-right: 5px;">CVSS: ${v.cvss_score}</span>` : '';

                    vulnsHtml += `
                        <div style="background: rgba(0,0,0,0.2); padding: 10px; margin-bottom: 8px; border-left: 3px solid ${severityColor};">
                            <div style="display:flex; justify-content:space-between;">
                                <strong style="color: #E2E8F0;">${v.title}</strong>
                                <div>
                                    ${cvssDisplay}
                                    <span style="color: ${severityColor}; font-size: 0.8em; border: 1px solid ${severityColor}; padding: 2px 6px; border-radius: 4px;">${v.severity}</span>
                                </div>
                            </div>
                            <div style="color: #A0AEC0; font-size: 0.9em; margin-top: 4px;">${v.description}</div>
                        </div>
                    `;
                });
            }

            let recsHtml = '';
            if (analysis.recommendations && analysis.recommendations.length > 0) {
                recsHtml = '<h4>√ñneriler:</h4><ul style="padding-left: 20px; color: #CCD6F6;">';
                analysis.recommendations.forEach(r => {
                    recsHtml += `<li>${r}</li>`;
                });
                recsHtml += '</ul>';
            }

            resultDiv.innerHTML = `
                <div style="background: linear-gradient(180deg, rgba(121, 40, 202, 0.15) 0%, rgba(10, 25, 47, 0.3) 100%); 
                            border: 1px solid #7928CA; border-radius: 8px; padding: 20px; animation: fadeIn 0.5s;">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                        <h3 style="margin: 0; color: #E2E8F0; display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5em;">ü§ñ</span> AI G√ºvenlik Analizi
                        </h3>
                        <div style="text-align: right;">
                            <div style="font-size: 0.8em; color: #A0AEC0;">Risk Skoru</div>
                            <div style="font-size: 1.5em; font-weight: bold; color: ${riskColor};">${analysis.risk_score}/10</div>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 15px; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 6px; border-left: 4px solid #3B82F6;">
                        <strong>√ñzet:</strong> <span style="color: #CCD6F6;">${analysis.summary}</span>
                    </div>
                    
                    ${vulnsHtml}
                    ${recsHtml}
                </div>
            `;
        } else {
            resultDiv.innerHTML = `
                <div style="background: rgba(245, 0, 0, 0.1); border: 1px solid #F50000; border-radius: 8px; padding: 20px;">
                    <div style="color: #F50000;">‚ö†Ô∏è Analiz hatasƒ±: ${data.error}</div>
                </div>
            `;
        }
    } catch (error) {
        console.error('AI Error:', error);
        resultDiv.innerHTML = `
            <div style="background: rgba(245, 0, 0, 0.1); border: 1px solid #F50000; border-radius: 8px; padding: 20px;">
                <div style="color: #F50000;">‚ö†Ô∏è Baƒülantƒ± hatasƒ±: ${error.message}</div>
            </div>
        `;
    } finally {
        btn.disabled = false;
        btn.innerHTML = '‚ú® AI ile Tekrar Analiz Et';
        btn.style.opacity = '1';
    }
}

// Auto Fill Button
const autoFillBtn = document.querySelector('.btn-auto-fill');
if (autoFillBtn) {
    autoFillBtn.addEventListener('click', () => {
        // Auto-fill with local network range (placeholder)
        const inputField = document.querySelector('.input-field');
        if (inputField) {
            inputField.value = '10.0.2.0/24';
            console.log('Auto-filled target range');
        }
    });
}

// Search Input
const searchInput = document.querySelector('.search-input');
if (searchInput) {
    searchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();

        document.querySelectorAll('.device-item').forEach(device => {
            const deviceName = device.querySelector('.device-name').textContent.toLowerCase();
            if (deviceName.includes(searchTerm)) {
                device.style.display = 'flex';
            } else {
                device.style.display = 'none';
            }
        });
    });
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    console.log('Pentest Otomasyon Motoru initialized');
    updatePortSelectionState(); // Ensure correct initial state
});
